<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>そんなこと覚えてない </title>
    <link>https://blog.eiel.info/tags/%E5%86%85%E5%8C%85%E8%A1%A8%E8%A8%98/</link>
    <language>en-us</language>
    <author>Tomohiko Himura</author>
    <rights>(C) 2018</rights>
    <updated>2015-12-06 21:50:42 &#43;0900 &#43;0900</updated>

    
      
        <item>
          <title>内包表記とPythonと… - #LT駆動 21</title>
          <link>https://blog.eiel.info/blog/2015/12/06/ltdd-21-python-option/</link>
          <pubDate>Sun, 06 Dec 2015 21:50:42 &#43;0900</pubDate>
          <author>Tomohiko Himura</author>
          <guid>https://blog.eiel.info/blog/2015/12/06/ltdd-21-python-option/</guid>
          <description>&lt;p&gt;&lt;a href=&#34;https://github.com/LTDD/Sessions/wiki/LT%E9%A7%86%E5%8B%95%E9%96%8B%E7%99%BA21&#34;&gt;LT駆動開発21&lt;/a&gt;でLTしてきました。
タイトル「内包表記とPythonと…Option」です。
PyCon Mini Hiroshima用に用意してたネタですが、参加できなかったので放出しました。
Pythonの内包表記でScalaのOptionのようなものをつくってみました。&lt;/p&gt;

&lt;p&gt;Pythonの内包表記はScalaではfor式で表現ができます。
Scalaではリスト以外のものでもfor式が使えます。
代表格として&lt;code&gt;Option&lt;/code&gt;が上げられます。
ということで、PythonにもOptionクラスをつくり内包表記で利用できるようにしてみました。
スライドに登場するように内包表記に対応するために、&lt;code&gt;__iter__&lt;/code&gt;と&lt;code&gt;next&lt;/code&gt;メソッドを実装をしています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Option:
    def __init__(self, value):
        self.value = value
    def __iter__(self):
        return self
    def next(self):
        if self.value == None:
            raise StopIteration
        else:
            ret = self.value
        self.value = None
            return ret
    def __str__(self):
          if self.value == None:
               return &amp;quot;Nothing&amp;quot;
          else:
               return &amp;quot;Some(%d)&amp;quot; % self.value

def add(x, y):
  return [ x_+ y_ 
    for x_ in x 
    for y_ in y
  ]

add(Option(1), Option(2))    # =&amp;gt; [3]
add(Option(1), Option(None))  # =&amp;gt; []
add(Option(None), Option(2))  # =&amp;gt; []
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;LT駆動はゆるふわに個々が学んだことを発表していてとても楽しいです。気軽に参加してみてください。&lt;/p&gt;

&lt;script async class=&#34;speakerdeck-embed&#34; data-id=&#34;c891be7c13ac4b8b8076e321e11b352d&#34; data-ratio=&#34;1.33333333333333&#34; src=&#34;//speakerdeck.com/assets/embed.js&#34;&gt;&lt;/script&gt;
</description>
        </item>
      
    
      
        <item>
          <title>内包表記について、すごい合同勉強会で話した</title>
          <link>https://blog.eiel.info/blog/2014/11/02/internal-definitia-great-study/</link>
          <pubDate>Sun, 02 Nov 2014 12:25:00 &#43;0900</pubDate>
          <author>Tomohiko Himura</author>
          <guid>https://blog.eiel.info/blog/2014/11/02/internal-definitia-great-study/</guid>
          <description>

&lt;p&gt;&lt;a href=&#34;https://github.com/LTDD/Sessions/wiki/%E3%81%99%E3%81%94%E3%81%84%E5%90%88%E5%90%8C%E5%8B%89%E5%BC%B7%E4%BC%9A&#34;&gt;すごい合同勉強会2014 in 広島&lt;/a&gt;でセッションしたので内容を公開しておく。&lt;/p&gt;

&lt;p&gt;今回は「私がモナドの内包表記という名前を知った時の感覚を伝えよう」というのが目的でした。
さりげなく「私がモナドに感じている効能を伝える」というのもしているのですが、そこは本当にさりげなく。&lt;/p&gt;

&lt;script async class=&#34;speakerdeck-embed&#34; data-id=&#34;7cb24810446c0132e04e4e24d1028d6d&#34; data-ratio=&#34;1.33333333333333&#34; src=&#34;//speakerdeck.com/assets/embed.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;内包表記。その意味を知らずに5年前ぐらいにpythonで利用していて、forやif文字通りにうけとっており、その動作を正しく理解できてないときがありました。
現在とその間にHaskellを学び、その5年前の自分に内包表記を伝えるにはという観点で話を進めました。&lt;/p&gt;

&lt;p&gt;まず、リストの内包表記ですが、リストを生成を簡単にしてくれる機能です。&lt;/p&gt;

&lt;p&gt;内包表記は、どうやら数学の集合の記法である内包的記法に由来するそうで、「&lt;a href=&#34;http://www.amazon.co.jp/gp/product/427406896X/ref=as_li_ss_tl?ie=UTF8&amp;amp;camp=247&amp;amp;creative=7399&amp;amp;creativeASIN=427406896X&amp;amp;linkCode=as2&amp;amp;tag=eiel-22&#34;&gt;関数プログラミング入門 ―Haskellで学ぶ原理と技法―&lt;/a&gt;」か何かで読んだ記憶があります。&lt;/p&gt;

&lt;p&gt;その対になる記法として外延的記法があります。
これは具体的な中身を列挙する方法で、普段のリテラル表記ともみなすことができます。
リテラルで地道にかくのではなく、てプログラミングで自動生成しようというのが内包表記と言えそうです。&lt;/p&gt;

&lt;p&gt;Haskellの内包表記は ジェネレータとガードと呼ばれる真偽値を並べることで作成します。
&lt;code&gt;x &amp;lt;- [1..9]&lt;/code&gt; の部分がジェネレータです。あと真偽値を返す式がガードになります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;参考 &lt;a href=&#34;https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-420003.11&#34;&gt;3 Expressions - Haskell 2010&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;pythonではジェネレータとガードが for と if で表現されています。
直感的だし、キーワードの使いまわしとも言えそうです。
(関係ないけど、C++はキーワードの使いまわしたいへんそうだなぁって思った)&lt;/p&gt;

&lt;p&gt;あとはジェネレータを並べた際にどうなるか、というのがわかればリストの内包表記はうまく使えるのではないかと思います。
直積をとる。つまり、全部のパターンをつくる。
あとはフィルタで、致しているものを求めるだけですね。&lt;/p&gt;

&lt;p&gt;そういえば、リストモナドでできることですね。複数答えがある場合にリストモナドを使うとすべての回答が得られます。&lt;/p&gt;

&lt;p&gt;よく内包表記がmapやfilterと比較されることがありますが、そもそも同一に扱っても面白いことは特にない気がします。
目的しだいではmapやfilterを使うより便利だと考えてよいと思います。&lt;/p&gt;

&lt;p&gt;蛇足ですが、モナドの有効性として、コードが斜めに述びる性質がある際に真っ直ぐに伸ばすことができるみたいなイメージを持っています。
それをさりげなく言っていたのですが、後で&lt;a href=&#34;https://twitter.com/nobkz&#34;&gt;はなださん&lt;/a&gt;のセッションで実例がでてきました。&lt;/p&gt;

&lt;p&gt;さて、ここまでくると内包表記とSQLの類似性が簡単に説明できるし、具体例にしやすいので、SQLと絡めた話をしました。
あとはモナドの内包表記へと一般化する話です。具体例のリストから、Maybeへと繋ぎ一般化して終わりです。&lt;/p&gt;

&lt;p&gt;Rubyの例でflattenしている部分がありますが、あの辺はリストモナドがいつも勝手にやってくれてるところで、さりげなく強調していたりしますね。&lt;/p&gt;

&lt;p&gt;モナドはなんか怖いとか言われますが、それはさておいて内包表記は便利なので知っておいて損はないと思います。&lt;/p&gt;

&lt;p&gt;会場はわりとポカーンとしていましたが「誰かの何かに役に立てばいいなぁ」ということでスライドと簡単な解説を残しておきます。&lt;/p&gt;

&lt;h3 id=&#34;登場したコード:1aaa3329fe0e09fc9b43bfdccf024329&#34;&gt;登場したコード&lt;/h3&gt;

&lt;p&gt;コピペしやすいように置いておきます。
主に対話環境用に。&lt;/p&gt;

&lt;p&gt;Haskell&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;[(x,y) | x &amp;lt;- [1..9], y &amp;lt;- [1..9], x * y == 24]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;[(x,y,z) | x &amp;lt;- [1..9], y &amp;lt;- [1..9], z &amp;lt;- [1..9], x * y * z == 24]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-Haskell&#34;&gt;:set -XTransformListComp
[ (x,y) | x &amp;lt;- [1..9], y &amp;lt;- [1..9], x * y == 24, then take 2]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;:set -XTransformListComp
:m GHC.Exts
[ (x,y) | x &amp;lt;- [1..9], y &amp;lt;- [1..9], x * y == 24, then sortWith by y]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;:set -XMonadComprehensions
[ (x,y) | x &amp;lt;- Just 3, y &amp;lt;- Just 8, x * y == 24]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Python&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[(x,y) for x in range(1,10) for y in range(1,10) if x * y == 24]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ruby&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;[*1..9].map do |x|
  [*1..9].map do |y|
    [x,y]
  end
end.flatten(1).select do |x,y|
  x * y == 24
end
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;[*1..9].map do |x|
  [*1..9].map do |y|
    [*1..9].map do |z|
      [x,y,z]
    end
  end
end.flatten(2).select do |x,y,z|
  x * y * z == 24
end
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;[*1..9].product([*1..9],[*1..9]).select do |x,y,z|
    x * y * z == 24
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SQL&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT x,y
FROM generate_series(1,9) AS X,
     generate_series(1,9) AS Y
WHERE x * y = 24;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT x,y,z
FROM generate_series(1,9) AS X,
     generate_series(1,9) AS Y,
     generate_series(1,9) AS Z
WHERE x * y * z = 24;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;参考文献:1aaa3329fe0e09fc9b43bfdccf024329&#34;&gt;参考文献&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://ja.wikipedia.org/wiki/%E5%86%85%E5%8C%85%E3%81%A8%E5%A4%96%E5%BB%B6&#34;&gt;内包と外延 - Wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://ja.wikipedia.org/wiki/%E9%9B%86%E5%90%88&#34;&gt;内包的記法の出展 - 集合 - Wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.python.jp/2/tutorial/datastructures.html#id6&#34;&gt;5. データ構造 — Python 2.7ja1 documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.kotha.net/ghcguide_ja/7.6.2/syntax-extns.html#generalised-list-comprehensions&#34;&gt;7.3. 構文的拡張 - 内包表記の拡張&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.kotha.net/ghcguide_ja/7.6.2/syntax-extns.html#monad-comprehensions&#34;&gt;7.3. 構文的拡張 Monadの内包表記&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/uduki845/items/d60dc51ad3a26b9ab430&#34;&gt;Haskell - ghciで言語拡張を有効にする - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;関連リンク:1aaa3329fe0e09fc9b43bfdccf024329&#34;&gt;関連リンク&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;blog/2014/11/02/great-study-2014/&#34;&gt;すごい合同勉強会2014 in 広島を開催した - そんなこと覚えてない&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
      
    

  </channel>
</rss>
