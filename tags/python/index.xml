<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>そんなこと覚えてない </title>
    <link>https://blog.eiel.info/tags/python/</link>
    <language>en-us</language>
    <author>Tomohiko Himura</author>
    <rights>(C) 2018</rights>
    <updated>2015-12-06 21:50:42 &#43;0900 &#43;0900</updated>

    
      
        <item>
          <title>内包表記とPythonと… - #LT駆動 21</title>
          <link>https://blog.eiel.info/blog/2015/12/06/ltdd-21-python-option/</link>
          <pubDate>Sun, 06 Dec 2015 21:50:42 &#43;0900</pubDate>
          <author>Tomohiko Himura</author>
          <guid>https://blog.eiel.info/blog/2015/12/06/ltdd-21-python-option/</guid>
          <description>&lt;p&gt;&lt;a href=&#34;https://github.com/LTDD/Sessions/wiki/LT%E9%A7%86%E5%8B%95%E9%96%8B%E7%99%BA21&#34;&gt;LT駆動開発21&lt;/a&gt;でLTしてきました。
タイトル「内包表記とPythonと…Option」です。
PyCon Mini Hiroshima用に用意してたネタですが、参加できなかったので放出しました。
Pythonの内包表記でScalaのOptionのようなものをつくってみました。&lt;/p&gt;

&lt;p&gt;Pythonの内包表記はScalaではfor式で表現ができます。
Scalaではリスト以外のものでもfor式が使えます。
代表格として&lt;code&gt;Option&lt;/code&gt;が上げられます。
ということで、PythonにもOptionクラスをつくり内包表記で利用できるようにしてみました。
スライドに登場するように内包表記に対応するために、&lt;code&gt;__iter__&lt;/code&gt;と&lt;code&gt;next&lt;/code&gt;メソッドを実装をしています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Option:
    def __init__(self, value):
        self.value = value
    def __iter__(self):
        return self
    def next(self):
        if self.value == None:
            raise StopIteration
        else:
            ret = self.value
        self.value = None
            return ret
    def __str__(self):
          if self.value == None:
               return &amp;quot;Nothing&amp;quot;
          else:
               return &amp;quot;Some(%d)&amp;quot; % self.value

def add(x, y):
  return [ x_+ y_ 
    for x_ in x 
    for y_ in y
  ]

add(Option(1), Option(2))    # =&amp;gt; [3]
add(Option(1), Option(None))  # =&amp;gt; []
add(Option(None), Option(2))  # =&amp;gt; []
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;LT駆動はゆるふわに個々が学んだことを発表していてとても楽しいです。気軽に参加してみてください。&lt;/p&gt;

&lt;script async class=&#34;speakerdeck-embed&#34; data-id=&#34;c891be7c13ac4b8b8076e321e11b352d&#34; data-ratio=&#34;1.33333333333333&#34; src=&#34;//speakerdeck.com/assets/embed.js&#34;&gt;&lt;/script&gt;
</description>
        </item>
      
    
      
        <item>
          <title>内包表記について、すごい合同勉強会で話した</title>
          <link>https://blog.eiel.info/blog/2014/11/02/internal-definitia-great-study/</link>
          <pubDate>Sun, 02 Nov 2014 12:25:00 &#43;0900</pubDate>
          <author>Tomohiko Himura</author>
          <guid>https://blog.eiel.info/blog/2014/11/02/internal-definitia-great-study/</guid>
          <description>

&lt;p&gt;&lt;a href=&#34;https://github.com/LTDD/Sessions/wiki/%E3%81%99%E3%81%94%E3%81%84%E5%90%88%E5%90%8C%E5%8B%89%E5%BC%B7%E4%BC%9A&#34;&gt;すごい合同勉強会2014 in 広島&lt;/a&gt;でセッションしたので内容を公開しておく。&lt;/p&gt;

&lt;p&gt;今回は「私がモナドの内包表記という名前を知った時の感覚を伝えよう」というのが目的でした。
さりげなく「私がモナドに感じている効能を伝える」というのもしているのですが、そこは本当にさりげなく。&lt;/p&gt;

&lt;script async class=&#34;speakerdeck-embed&#34; data-id=&#34;7cb24810446c0132e04e4e24d1028d6d&#34; data-ratio=&#34;1.33333333333333&#34; src=&#34;//speakerdeck.com/assets/embed.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;内包表記。その意味を知らずに5年前ぐらいにpythonで利用していて、forやif文字通りにうけとっており、その動作を正しく理解できてないときがありました。
現在とその間にHaskellを学び、その5年前の自分に内包表記を伝えるにはという観点で話を進めました。&lt;/p&gt;

&lt;p&gt;まず、リストの内包表記ですが、リストを生成を簡単にしてくれる機能です。&lt;/p&gt;

&lt;p&gt;内包表記は、どうやら数学の集合の記法である内包的記法に由来するそうで、「&lt;a href=&#34;http://www.amazon.co.jp/gp/product/427406896X/ref=as_li_ss_tl?ie=UTF8&amp;amp;camp=247&amp;amp;creative=7399&amp;amp;creativeASIN=427406896X&amp;amp;linkCode=as2&amp;amp;tag=eiel-22&#34;&gt;関数プログラミング入門 ―Haskellで学ぶ原理と技法―&lt;/a&gt;」か何かで読んだ記憶があります。&lt;/p&gt;

&lt;p&gt;その対になる記法として外延的記法があります。
これは具体的な中身を列挙する方法で、普段のリテラル表記ともみなすことができます。
リテラルで地道にかくのではなく、てプログラミングで自動生成しようというのが内包表記と言えそうです。&lt;/p&gt;

&lt;p&gt;Haskellの内包表記は ジェネレータとガードと呼ばれる真偽値を並べることで作成します。
&lt;code&gt;x &amp;lt;- [1..9]&lt;/code&gt; の部分がジェネレータです。あと真偽値を返す式がガードになります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;参考 &lt;a href=&#34;https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-420003.11&#34;&gt;3 Expressions - Haskell 2010&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;pythonではジェネレータとガードが for と if で表現されています。
直感的だし、キーワードの使いまわしとも言えそうです。
(関係ないけど、C++はキーワードの使いまわしたいへんそうだなぁって思った)&lt;/p&gt;

&lt;p&gt;あとはジェネレータを並べた際にどうなるか、というのがわかればリストの内包表記はうまく使えるのではないかと思います。
直積をとる。つまり、全部のパターンをつくる。
あとはフィルタで、致しているものを求めるだけですね。&lt;/p&gt;

&lt;p&gt;そういえば、リストモナドでできることですね。複数答えがある場合にリストモナドを使うとすべての回答が得られます。&lt;/p&gt;

&lt;p&gt;よく内包表記がmapやfilterと比較されることがありますが、そもそも同一に扱っても面白いことは特にない気がします。
目的しだいではmapやfilterを使うより便利だと考えてよいと思います。&lt;/p&gt;

&lt;p&gt;蛇足ですが、モナドの有効性として、コードが斜めに述びる性質がある際に真っ直ぐに伸ばすことができるみたいなイメージを持っています。
それをさりげなく言っていたのですが、後で&lt;a href=&#34;https://twitter.com/nobkz&#34;&gt;はなださん&lt;/a&gt;のセッションで実例がでてきました。&lt;/p&gt;

&lt;p&gt;さて、ここまでくると内包表記とSQLの類似性が簡単に説明できるし、具体例にしやすいので、SQLと絡めた話をしました。
あとはモナドの内包表記へと一般化する話です。具体例のリストから、Maybeへと繋ぎ一般化して終わりです。&lt;/p&gt;

&lt;p&gt;Rubyの例でflattenしている部分がありますが、あの辺はリストモナドがいつも勝手にやってくれてるところで、さりげなく強調していたりしますね。&lt;/p&gt;

&lt;p&gt;モナドはなんか怖いとか言われますが、それはさておいて内包表記は便利なので知っておいて損はないと思います。&lt;/p&gt;

&lt;p&gt;会場はわりとポカーンとしていましたが「誰かの何かに役に立てばいいなぁ」ということでスライドと簡単な解説を残しておきます。&lt;/p&gt;

&lt;h3 id=&#34;登場したコード:1aaa3329fe0e09fc9b43bfdccf024329&#34;&gt;登場したコード&lt;/h3&gt;

&lt;p&gt;コピペしやすいように置いておきます。
主に対話環境用に。&lt;/p&gt;

&lt;p&gt;Haskell&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;[(x,y) | x &amp;lt;- [1..9], y &amp;lt;- [1..9], x * y == 24]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;[(x,y,z) | x &amp;lt;- [1..9], y &amp;lt;- [1..9], z &amp;lt;- [1..9], x * y * z == 24]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-Haskell&#34;&gt;:set -XTransformListComp
[ (x,y) | x &amp;lt;- [1..9], y &amp;lt;- [1..9], x * y == 24, then take 2]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;:set -XTransformListComp
:m GHC.Exts
[ (x,y) | x &amp;lt;- [1..9], y &amp;lt;- [1..9], x * y == 24, then sortWith by y]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;:set -XMonadComprehensions
[ (x,y) | x &amp;lt;- Just 3, y &amp;lt;- Just 8, x * y == 24]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Python&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[(x,y) for x in range(1,10) for y in range(1,10) if x * y == 24]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ruby&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;[*1..9].map do |x|
  [*1..9].map do |y|
    [x,y]
  end
end.flatten(1).select do |x,y|
  x * y == 24
end
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;[*1..9].map do |x|
  [*1..9].map do |y|
    [*1..9].map do |z|
      [x,y,z]
    end
  end
end.flatten(2).select do |x,y,z|
  x * y * z == 24
end
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;[*1..9].product([*1..9],[*1..9]).select do |x,y,z|
    x * y * z == 24
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SQL&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT x,y
FROM generate_series(1,9) AS X,
     generate_series(1,9) AS Y
WHERE x * y = 24;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT x,y,z
FROM generate_series(1,9) AS X,
     generate_series(1,9) AS Y,
     generate_series(1,9) AS Z
WHERE x * y * z = 24;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;参考文献:1aaa3329fe0e09fc9b43bfdccf024329&#34;&gt;参考文献&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://ja.wikipedia.org/wiki/%E5%86%85%E5%8C%85%E3%81%A8%E5%A4%96%E5%BB%B6&#34;&gt;内包と外延 - Wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://ja.wikipedia.org/wiki/%E9%9B%86%E5%90%88&#34;&gt;内包的記法の出展 - 集合 - Wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.python.jp/2/tutorial/datastructures.html#id6&#34;&gt;5. データ構造 — Python 2.7ja1 documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.kotha.net/ghcguide_ja/7.6.2/syntax-extns.html#generalised-list-comprehensions&#34;&gt;7.3. 構文的拡張 - 内包表記の拡張&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.kotha.net/ghcguide_ja/7.6.2/syntax-extns.html#monad-comprehensions&#34;&gt;7.3. 構文的拡張 Monadの内包表記&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/uduki845/items/d60dc51ad3a26b9ab430&#34;&gt;Haskell - ghciで言語拡張を有効にする - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;関連リンク:1aaa3329fe0e09fc9b43bfdccf024329&#34;&gt;関連リンク&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;blog/2014/11/02/great-study-2014/&#34;&gt;すごい合同勉強会2014 in 広島を開催した - そんなこと覚えてない&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
      
    
      
        <item>
          <title>@soudai1025 がFizzBuzzのエントリで再帰についてかいてた。なんか違和感を感じた。</title>
          <link>https://blog.eiel.info/blog/2013/01/27/soudai-recursion/</link>
          <pubDate>Sun, 27 Jan 2013 01:05:00 &#43;0900</pubDate>
          <author>Tomohiko Himura</author>
          <guid>https://blog.eiel.info/blog/2013/01/27/soudai-recursion/</guid>
          <description>&lt;p&gt;&lt;a href=&#34;http://twitter.com/soudai1025&#34;&gt;@soudai1025&lt;/a&gt; が書いた&lt;a href=&#34;http://soudai1025.blogspot.jp/2013/01/pythonfizzbuzz.html?spref=fb&#34;&gt;ブログ記事にPythonでFizzBuzzとかしてみた&lt;/a&gt;というエントリーがあって、まーいろいろ、&lt;a href=&#34;http://blog.eiel.info/blog/2013/01/26/soudai-fizzbuzz/&#34;&gt;あって突っ込みをいれました。&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;この中で再帰に関する記述があります。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;で最後はみんな大好き再帰。
折角なのでループ文を使わずに与えられたintまでの１からの和を出してみました。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def sum(num, answer = 0):
    answer = answer + num
    num -= 1
    if num == 0: return answer
    return sum(num, answer)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;「この再帰なんかおかしくね？」って直感的に思った。&lt;/p&gt;

&lt;p&gt;おかしいというのはなんか複雑すぎないだろうか？ということである。answerって引数なくても実装できるよね。引き継ぎたい値がひとつしかないから戻り値で対応できる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def sum(num):
    if num == 1:
      return 1
    return num + sum(num-1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;うん。これだ。これが正しい。&lt;/p&gt;

&lt;p&gt;再帰を使う場合は、まず終了条件を考えます。この場合、num から 1へおりていくので、1で終了です。&lt;/p&gt;

&lt;p&gt;次にのこったそれ以外のときのことを考えます。num と n-1 の和を足せば求める値がもとめられることに気づくことができればあとはそのままかくだけです。
再帰を使うと今作成している関数が動いている前提で考えることができます。そのあたりに慣れるとさくさくかけます。&lt;/p&gt;

&lt;p&gt;再帰というのは スタック付きのループと見なせます。なのでループでできることはなんでも出きます。外のスコープの変数を引き継ぎたいときは、引数を増やせば伝搬できます。ただし、戻り値があるので、ひとつだけであれば伝搬可能です。この戻り値をリストにすることで複数の値を返すこともできます。&lt;/p&gt;

&lt;p&gt;ちなみに、普通の関数プログラマの場合、こういうときは reduce を使います。
再帰より読みやすいですからね。&lt;/p&gt;

&lt;p&gt;たぶん。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>@souda1025 に PythonでFizzBuzzとかしてみた に対抗しろって煽られたので。</title>
          <link>https://blog.eiel.info/blog/2013/01/26/soudai-fizzbuzz/</link>
          <pubDate>Sat, 26 Jan 2013 14:33:00 &#43;0900</pubDate>
          <author>Tomohiko Himura</author>
          <guid>https://blog.eiel.info/blog/2013/01/26/soudai-fizzbuzz/</guid>
          <description>

&lt;p&gt;&lt;a href=&#34;http://twitter.com/soudai1025&#34;&gt;@soudai1025&lt;/a&gt; が書いた&lt;a href=&#34;http://soudai1025.blogspot.jp/2013/01/pythonfizzbuzz.html?spref=fb&#34;&gt;ブログ記事にPythonでFizzBuzzとかしてみた&lt;/a&gt;というエントリーがあるのですが、Facebookでこういうコメントをみた。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;多分、ひむひむが対抗してくるはず。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;全力でお答えしましょう。&lt;/p&gt;

&lt;p&gt;とりあえず、普通 FizzBuzz かくならこうかくだろう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def fizzbuzz(number):
    if number % 15 == 0:  # number % 5 == 0 and number % 3 == 0
        return &amp;quot;FizzBuzz&amp;quot;
    elif number % 5 == 0:
        return &amp;quot;Buzz&amp;quot;
    elif number % 3 == 0:
        return &amp;quot;Fizz&amp;quot;
    else:
        return str(number)

if __name__ == &#39;__main__&#39;:
    number = int(raw_input(&amp;quot;Please enter an integer: &amp;quot;))
    print fizzbuzz(number)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;数値を入れると &lt;code&gt;数値の文字列&lt;/code&gt; か &amp;ldquo;Fizz&amp;rdquo; か &amp;ldquo;Buzz&amp;rdquo; か &amp;ldquo;FizzBuzz&amp;rdquo; を返す関数を用意するほうが柔軟性があり、わかりやすいです。&lt;/p&gt;

&lt;p&gt;さて、もとのコードを確認していきましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;int = int(raw_input(&amp;quot;Please enter an integer: &amp;quot;))

def do_fizz(int):
    if (int % 3) == 0:
        return 1
    return 0

def do_buzz(int):
    if (int % 5) == 0:
        return 2
    return 0

def do_answer(fizz, buzz):
    flag = fizz + buzz
    if flag == 0:
        print int #引数に居なくても外のintを参照出来る
    elif flag == 1:
        print &amp;quot;Fizz&amp;quot;
    elif flag == 2:
        print &amp;quot;Buzz&amp;quot;
    elif flag == 3:
        print &amp;quot;FizzBuzz&amp;quot;

do_answer(do_fizz(int), do_buzz(int))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、気になる点をあげていこう。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;do_answer&lt;/code&gt; 関数が外のスコープにアクセスしている。&lt;/li&gt;
&lt;li&gt;よくわからないフラグ処理がされている。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;do_answer&lt;/code&gt; の引数が意味不明。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;関数が外のスコープにアクセスしている:aa533cc5bfd0e8e446ea5505e1815d9f&#34;&gt;関数が外のスコープにアクセスしている&lt;/h2&gt;

&lt;p&gt;関数が外のスコープにアクセスしてしまうとその関数だけみたときに他の部分を確認しないといけないのでよくない。&lt;/p&gt;

&lt;p&gt;それぐらいなら引数を追加しましょう。&lt;/p&gt;

&lt;h2 id=&#34;よくわからないフラグ処理がされている:aa533cc5bfd0e8e446ea5505e1815d9f&#34;&gt;よくわからないフラグ処理がされている&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;do_fizz&lt;/code&gt; と &lt;code&gt;do_buzz&lt;/code&gt; が関数名から何をするのかさっぱりわからない。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;do_fizz&lt;/code&gt; は &lt;em&gt;3で割り切れる場合 1 を返し、それ以外の場合は 0 を返す関数である&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;do_buzz&lt;/code&gt; は &lt;em&gt;5で割り切れる場合 2 を返し、それ以外の場合は 0 を返す関数である&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ということはコードをよまなければわからない。ならば、関数の頭にコメントをかくか、そのような名前の関数にすべきだと思う。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;do_&lt;/code&gt; という接頭辞が着いている以上何かする関数だと想像するので、ここで &lt;code&gt;print&lt;/code&gt; されているのであれば、まだ良いと思うけど, iPhoneで閲覧していたらこの命名のせいで混乱しました。&lt;/p&gt;

&lt;h2 id=&#34;do-answer-の引数が意味不明:aa533cc5bfd0e8e446ea5505e1815d9f&#34;&gt;do_answer の引数が意味不明&lt;/h2&gt;

&lt;p&gt;fizz って何? buzz って何?&lt;/p&gt;

&lt;p&gt;&lt;code&gt;do_answer(do_fizz(int), do_buzz(int))&lt;/code&gt; これをみてわけがわかる人がいたら教えて欲しい。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;do_fizz&lt;/code&gt; と &lt;code&gt;do_buzz&lt;/code&gt; の実行結果を使うのであれば、関数内で使うべきだろう。&lt;code&gt;int&lt;/code&gt;をdo_answer に渡さない設計にしているのに &lt;code&gt;do_fizz&lt;/code&gt; と &lt;code&gt;do_buzz&lt;/code&gt; に渡しているのに ここで int の文字がふたつ見える。 &lt;strong&gt;わけがわからないよ&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;do_answer&lt;/code&gt; は &lt;code&gt;print&lt;/code&gt; するという点でまあ良いのじゃないかと思う。
ただ、doしないversionを用意しておけば&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;for n in range(1,int):
   print answer(do_fizz(n), do_buzz(n))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とかきかえることができて、&lt;code&gt;int&lt;/code&gt;までの FizzBuzz が表示できてナイスだと思います。&lt;/p&gt;

&lt;h2 id=&#34;まとめ:aa533cc5bfd0e8e446ea5505e1815d9f&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;「Haskell と Ruby で書いたらどうなるかを書け」という煽りな気がしたけど無視してみた。&lt;/p&gt;

&lt;p&gt;ついで、個人的感想。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;「Pythonって三項演算子どうやるんだろ？」って思ったんで調べて使ってみた。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;たぶん、&lt;code&gt;and&lt;/code&gt; &lt;code&gt;or&lt;/code&gt; で同様のことはできるけど、&lt;strong&gt;「3項演算子は読みにくいから使うな。」&lt;/strong&gt; ってことだと思う。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;phpの&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;$flag[] = (int % 3 == 0) ? 1 : 0;
$flag[] = (int % 5 == 0) ? 2 : 0;

$flag[&#39;fizz&#39;] = (int % 3 == 0) ? 1 :0;
$flag[&#39;buzz&#39;] = (int % 5 == 0) ? 2 :0;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;みたいにいきなりList（配列）を作る書き方がPythonでも出来ると思うんだけど知識不足。
公式チュートリアルやったらどっかで出てくるかな？ｗ&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;初期化してない変数に無理矢理突っ込むということのほうがおかしい。
かくなら&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;flag = []
flag.append(fizz)
flag.append(buzz)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となるのではないでしょうか。&lt;/p&gt;

&lt;p&gt;このように中途半端なコードを書いて誰かを煽ると添削とかしてもらえるらしいです。非常に勉強する際にショートカットになりますし、煽られるほうも勉強になります。どんどん真似していきましょう。&lt;/p&gt;

&lt;p&gt;まあ、せっかくなので Haskell でも書いておきました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import Control.Monad

main = do
  putStr &amp;quot;please enter an integer:&amp;quot;
  number &amp;lt;- fmap read $ getLine
  putStrLn . fizzbuzz $ number
  -- forM_ [1..number] $ \n -&amp;gt;
  --       putStrLn . fizzbuzz $ n

fizzbuzz :: Int -&amp;gt; String
fizzbuzz n | n `mod` 15 == 0 = &amp;quot;FizzBuzz&amp;quot;
           | n `mod`  5 == 0 = &amp;quot;Buzz&amp;quot;
           | n `mod`  3 == 0 = &amp;quot;Fizz&amp;quot;
           | otherwise       = show n
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再帰についても書きたいですが、話がずれてしまうので、また別の機会に。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/eiel/soudai-FizzBuzz&#34;&gt;リポジトリはこちらに用意しておきました。&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;トマホークおまちしています。&lt;/p&gt;
</description>
        </item>
      
    

  </channel>
</rss>
