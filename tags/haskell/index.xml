<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>そんなこと覚えてない </title>
    <link>https://blog.eiel.info/tags/haskell/</link>
    <language>en-us</language>
    <author>Tomohiko Himura</author>
    <rights>(C) 2018</rights>
    <updated>2015-09-05 23:37:56 &#43;0900 &#43;0900</updated>

    
      
        <item>
          <title>モナドがくれたものという話をした - #LT駆動</title>
          <link>https://blog.eiel.info/blog/2015/09/05/ltdd-18/</link>
          <pubDate>Sat, 05 Sep 2015 23:37:56 &#43;0900</pubDate>
          <author>Tomohiko Himura</author>
          <guid>https://blog.eiel.info/blog/2015/09/05/ltdd-18/</guid>
          <description>&lt;p&gt;&lt;a href=&#34;https://github.com/LTDD/Sessions/wiki/LT%E9%A7%86%E5%8B%95%E9%96%8B%E7%99%BA18&#34;&gt;LT駆動開発18 - 秋(not 安芸)の宮島&lt;/a&gt;で「モナドがくれたもの」というタイトルでLTしてきました。雑なLTです。&lt;/p&gt;

&lt;script async class=&#34;speakerdeck-embed&#34; data-id=&#34;3a6147ab3edb43948faee24621302505&#34; data-ratio=&#34;1.33333333333333&#34; src=&#34;//speakerdeck.com/assets/embed.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;モナドの利点を問われたので、似ているパティーン(パターン)が除去できるんだぜ。みじかくかけるんだぜ。
「裏で毎回同じことやってくれてるんすよ。これはコンピュータの得意なことだよな。だけど、その内容はモナドの種類によって違うんだぜ」&lt;/p&gt;

&lt;p&gt;的な話をしておきました。&lt;/p&gt;

&lt;p&gt;動作確認につかったコードはここに投げておきます。&lt;/p&gt;

&lt;script src=&#34;https://gist.github.com/eiel/1c96044764224ed91e32.js&#34;&gt;&lt;/script&gt;
</description>
        </item>
      
    
      
        <item>
          <title>モナド則だけ見つめていたい - LT駆動開発14</title>
          <link>https://blog.eiel.info/blog/2015/05/02/want-staring-monad-only-ltdd-14/</link>
          <pubDate>Sat, 02 May 2015 13:00:00 &#43;0900</pubDate>
          <author>Tomohiko Himura</author>
          <guid>https://blog.eiel.info/blog/2015/05/02/want-staring-monad-only-ltdd-14/</guid>
          <description>

&lt;p&gt;&lt;a href=&#34;https://github.com/LTDD/Sessions/wiki/LT%E9%A7%86%E5%8B%95%E9%96%8B%E7%99%BA14&#34;&gt;LT駆動開発14&lt;/a&gt;に参加した。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://xenobladex.jp/&#34;&gt;ゼノブレイドクロス&lt;/a&gt;発売記念でモナドの話をしといた。&lt;/p&gt;

&lt;script async class=&#34;speakerdeck-embed&#34; data-id=&#34;b016eb833b804fca903db71dc869bae0&#34; data-ratio=&#34;1.33333333333333&#34; src=&#34;//speakerdeck.com/assets/embed.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;Stateモナドを簡約して、Stateモナドを説明しようとおもったけどうまくいかなくてボツになりました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/eielh/items/3612e4233c9c4a2d80a0&#34;&gt;Haskell - Stateモナドを手で簡約してみたりしていた - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;そんなわけで&lt;a href=&#34;http://ja.wikibooks.org/wiki/Haskell/%E5%9C%8F%E8%AB%96&#34;&gt;Haskell/圏論 - Wikibooks&lt;/a&gt;を元ネタにモナド則を辿ってみました。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;a -&amp;gt; M b&lt;/code&gt;って型の関数を並べるにはfmapしてjoinしてを間にはさむことがポイントな気がしたことがあったのでその話です。
&lt;code&gt;a -&amp;gt; M b&lt;/code&gt;な関数を組み合わせると &lt;code&gt;M b -&amp;gt; M (M c)&lt;/code&gt; になって &lt;code&gt;M (M c) -&amp;gt; M (M (M d))&lt;/code&gt; とどんどんMが増えていってしまうのですが、モナドであれば&lt;code&gt;M d&lt;/code&gt;にできるわけです。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;a -&amp;gt; M b&lt;/code&gt;ってなんなんだって話になってきますが&lt;code&gt;M a -&amp;gt; M b&lt;/code&gt;でも良いけど、&lt;code&gt;a -&amp;gt; M b&lt;/code&gt; のほうがあつかいやすいよね。だって&lt;code&gt;M&lt;/code&gt;は外せないんだから外れているものが受け取れたら便利じゃないですか。
結果的に残ったものは &lt;strong&gt;何度も同じことをしないといけない部分&lt;/strong&gt;を隠すことができます。
その内容を自由に取り替えできちゃうのがモナドの魅力なのだと思う。&lt;/p&gt;

&lt;p&gt;そしてMに関する操作は裏でひそかに行われて、命令書を構築したり、失敗していたら何もしなかったり、可能性すべてを記録したり、単に設定した値をおけるだけだったり、するだけだと思われます。&lt;/p&gt;

&lt;h3 id=&#34;関連:b742772047f9f19a088e8c7ef8bf510f&#34;&gt;関連&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://qiita.com/eielh/items/3612e4233c9c4a2d80a0&#34;&gt;Haskell - Stateモナドを手で簡約してみたりしていた - Qiita&lt;/a&gt;&lt;/p&gt;

&lt;iframe src=&#34;http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=eiel-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=B00T73HQHQ&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;
</description>
        </item>
      
    
      
        <item>
          <title>内包表記について、すごい合同勉強会で話した</title>
          <link>https://blog.eiel.info/blog/2014/11/02/internal-definitia-great-study/</link>
          <pubDate>Sun, 02 Nov 2014 12:25:00 &#43;0900</pubDate>
          <author>Tomohiko Himura</author>
          <guid>https://blog.eiel.info/blog/2014/11/02/internal-definitia-great-study/</guid>
          <description>

&lt;p&gt;&lt;a href=&#34;https://github.com/LTDD/Sessions/wiki/%E3%81%99%E3%81%94%E3%81%84%E5%90%88%E5%90%8C%E5%8B%89%E5%BC%B7%E4%BC%9A&#34;&gt;すごい合同勉強会2014 in 広島&lt;/a&gt;でセッションしたので内容を公開しておく。&lt;/p&gt;

&lt;p&gt;今回は「私がモナドの内包表記という名前を知った時の感覚を伝えよう」というのが目的でした。
さりげなく「私がモナドに感じている効能を伝える」というのもしているのですが、そこは本当にさりげなく。&lt;/p&gt;

&lt;script async class=&#34;speakerdeck-embed&#34; data-id=&#34;7cb24810446c0132e04e4e24d1028d6d&#34; data-ratio=&#34;1.33333333333333&#34; src=&#34;//speakerdeck.com/assets/embed.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;内包表記。その意味を知らずに5年前ぐらいにpythonで利用していて、forやif文字通りにうけとっており、その動作を正しく理解できてないときがありました。
現在とその間にHaskellを学び、その5年前の自分に内包表記を伝えるにはという観点で話を進めました。&lt;/p&gt;

&lt;p&gt;まず、リストの内包表記ですが、リストを生成を簡単にしてくれる機能です。&lt;/p&gt;

&lt;p&gt;内包表記は、どうやら数学の集合の記法である内包的記法に由来するそうで、「&lt;a href=&#34;http://www.amazon.co.jp/gp/product/427406896X/ref=as_li_ss_tl?ie=UTF8&amp;amp;camp=247&amp;amp;creative=7399&amp;amp;creativeASIN=427406896X&amp;amp;linkCode=as2&amp;amp;tag=eiel-22&#34;&gt;関数プログラミング入門 ―Haskellで学ぶ原理と技法―&lt;/a&gt;」か何かで読んだ記憶があります。&lt;/p&gt;

&lt;p&gt;その対になる記法として外延的記法があります。
これは具体的な中身を列挙する方法で、普段のリテラル表記ともみなすことができます。
リテラルで地道にかくのではなく、てプログラミングで自動生成しようというのが内包表記と言えそうです。&lt;/p&gt;

&lt;p&gt;Haskellの内包表記は ジェネレータとガードと呼ばれる真偽値を並べることで作成します。
&lt;code&gt;x &amp;lt;- [1..9]&lt;/code&gt; の部分がジェネレータです。あと真偽値を返す式がガードになります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;参考 &lt;a href=&#34;https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-420003.11&#34;&gt;3 Expressions - Haskell 2010&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;pythonではジェネレータとガードが for と if で表現されています。
直感的だし、キーワードの使いまわしとも言えそうです。
(関係ないけど、C++はキーワードの使いまわしたいへんそうだなぁって思った)&lt;/p&gt;

&lt;p&gt;あとはジェネレータを並べた際にどうなるか、というのがわかればリストの内包表記はうまく使えるのではないかと思います。
直積をとる。つまり、全部のパターンをつくる。
あとはフィルタで、致しているものを求めるだけですね。&lt;/p&gt;

&lt;p&gt;そういえば、リストモナドでできることですね。複数答えがある場合にリストモナドを使うとすべての回答が得られます。&lt;/p&gt;

&lt;p&gt;よく内包表記がmapやfilterと比較されることがありますが、そもそも同一に扱っても面白いことは特にない気がします。
目的しだいではmapやfilterを使うより便利だと考えてよいと思います。&lt;/p&gt;

&lt;p&gt;蛇足ですが、モナドの有効性として、コードが斜めに述びる性質がある際に真っ直ぐに伸ばすことができるみたいなイメージを持っています。
それをさりげなく言っていたのですが、後で&lt;a href=&#34;https://twitter.com/nobkz&#34;&gt;はなださん&lt;/a&gt;のセッションで実例がでてきました。&lt;/p&gt;

&lt;p&gt;さて、ここまでくると内包表記とSQLの類似性が簡単に説明できるし、具体例にしやすいので、SQLと絡めた話をしました。
あとはモナドの内包表記へと一般化する話です。具体例のリストから、Maybeへと繋ぎ一般化して終わりです。&lt;/p&gt;

&lt;p&gt;Rubyの例でflattenしている部分がありますが、あの辺はリストモナドがいつも勝手にやってくれてるところで、さりげなく強調していたりしますね。&lt;/p&gt;

&lt;p&gt;モナドはなんか怖いとか言われますが、それはさておいて内包表記は便利なので知っておいて損はないと思います。&lt;/p&gt;

&lt;p&gt;会場はわりとポカーンとしていましたが「誰かの何かに役に立てばいいなぁ」ということでスライドと簡単な解説を残しておきます。&lt;/p&gt;

&lt;h3 id=&#34;登場したコード:1aaa3329fe0e09fc9b43bfdccf024329&#34;&gt;登場したコード&lt;/h3&gt;

&lt;p&gt;コピペしやすいように置いておきます。
主に対話環境用に。&lt;/p&gt;

&lt;p&gt;Haskell&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;[(x,y) | x &amp;lt;- [1..9], y &amp;lt;- [1..9], x * y == 24]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;[(x,y,z) | x &amp;lt;- [1..9], y &amp;lt;- [1..9], z &amp;lt;- [1..9], x * y * z == 24]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-Haskell&#34;&gt;:set -XTransformListComp
[ (x,y) | x &amp;lt;- [1..9], y &amp;lt;- [1..9], x * y == 24, then take 2]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;:set -XTransformListComp
:m GHC.Exts
[ (x,y) | x &amp;lt;- [1..9], y &amp;lt;- [1..9], x * y == 24, then sortWith by y]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;:set -XMonadComprehensions
[ (x,y) | x &amp;lt;- Just 3, y &amp;lt;- Just 8, x * y == 24]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Python&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[(x,y) for x in range(1,10) for y in range(1,10) if x * y == 24]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ruby&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;[*1..9].map do |x|
  [*1..9].map do |y|
    [x,y]
  end
end.flatten(1).select do |x,y|
  x * y == 24
end
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;[*1..9].map do |x|
  [*1..9].map do |y|
    [*1..9].map do |z|
      [x,y,z]
    end
  end
end.flatten(2).select do |x,y,z|
  x * y * z == 24
end
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;[*1..9].product([*1..9],[*1..9]).select do |x,y,z|
    x * y * z == 24
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SQL&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT x,y
FROM generate_series(1,9) AS X,
     generate_series(1,9) AS Y
WHERE x * y = 24;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT x,y,z
FROM generate_series(1,9) AS X,
     generate_series(1,9) AS Y,
     generate_series(1,9) AS Z
WHERE x * y * z = 24;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;参考文献:1aaa3329fe0e09fc9b43bfdccf024329&#34;&gt;参考文献&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://ja.wikipedia.org/wiki/%E5%86%85%E5%8C%85%E3%81%A8%E5%A4%96%E5%BB%B6&#34;&gt;内包と外延 - Wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://ja.wikipedia.org/wiki/%E9%9B%86%E5%90%88&#34;&gt;内包的記法の出展 - 集合 - Wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.python.jp/2/tutorial/datastructures.html#id6&#34;&gt;5. データ構造 — Python 2.7ja1 documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.kotha.net/ghcguide_ja/7.6.2/syntax-extns.html#generalised-list-comprehensions&#34;&gt;7.3. 構文的拡張 - 内包表記の拡張&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.kotha.net/ghcguide_ja/7.6.2/syntax-extns.html#monad-comprehensions&#34;&gt;7.3. 構文的拡張 Monadの内包表記&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiita.com/uduki845/items/d60dc51ad3a26b9ab430&#34;&gt;Haskell - ghciで言語拡張を有効にする - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;関連リンク:1aaa3329fe0e09fc9b43bfdccf024329&#34;&gt;関連リンク&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;blog/2014/11/02/great-study-2014/&#34;&gt;すごい合同勉強会2014 in 広島を開催した - そんなこと覚えてない&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Haskell のフィールドラベルをもつデータ型について</title>
          <link>https://blog.eiel.info/blog/2014/09/06/datatypes-with-field-labels-for-haskell/</link>
          <pubDate>Sat, 06 Sep 2014 09:26:00 &#43;0900</pubDate>
          <author>Tomohiko Himura</author>
          <guid>https://blog.eiel.info/blog/2014/09/06/datatypes-with-field-labels-for-haskell/</guid>
          <description>

&lt;p&gt;Haskellのレコード構文というかフィールドラベルをもつデータ型についてなんだけど、苦手意識というか更新の方法を最近までよくしらなくてうまく使えてなかった。
わかったことを含めて書いておく。&lt;/p&gt;

&lt;p&gt;フィールドラベルをもつデータ型はざっくりいえば、構造体のようなものである。名前と年齢をもつ「人」を表現する型をつくってみよう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;data Person = Person { name :: String, age :: Int } deriving Show
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上記はフィールラベルがないデータ型にいろいろおまけがついてくるだけなので&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;data Perosn = Person String Int
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とした場合と同じような使い方ができる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;ghci&amp;gt; data Person = Person { name :: String, age :: Int } deriving Show
ghci&amp;gt; Person &amp;quot;eiel&amp;quot; 30
Person {name = &amp;quot;eiel&amp;quot;, age = 30}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;せっかくラベルがあるので、生かした使い方をしてみる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;ghci&amp;gt; data Person = Person { name :: String, age :: Int } deriving Show
ghci&amp;gt; Person { name = &amp;quot;eiel&amp;quot;, age = 30 }
Person {name = &amp;quot;eiel&amp;quot;, age = 30}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;冗長であるがわかりやすい。&lt;/p&gt;

&lt;p&gt;ラベルをつけるとよいところは値を取り出すのが少し楽になる。
ラベルと同名の関数が生成される。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;ghci&amp;gt; data Person = Person { name :: String, age :: Int } deriving Show
ghci&amp;gt; let person = Person { name = &amp;quot;eiel&amp;quot;, age = 30 }
ghci&amp;gt; name person
&amp;quot;eiel&amp;quot;
ghci&amp;gt; age person
30
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;特に意味はないが let を使わない場合。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;ghci&amp;gt; data Person = Person { name :: String, age :: Int } deriving Show
ghci&amp;gt; name Person { name = &amp;quot;eiel&amp;quot;, age = 30 }
&amp;quot;eiel&amp;quot;
ghci&amp;gt; age Person { name = &amp;quot;eiel&amp;quot;, age = 30 }
30
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;補足で、ラベルがない場合どうするか。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;ghci&amp;gt; data Person = Person { name :: String, age :: Int } deriving Show
ghci&amp;gt; let person = Person { name = &amp;quot;eiel&amp;quot;, age = 30 }
ghci&amp;gt; case person of Person name _ = name
&amp;quot;eiel&amp;quot;
ghci&amp;gt; case person of Person _ age = age
30
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;値を更新する方法。
ここをちゃんと知らなくて使ってなかったけど、とても簡単。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;ghci&amp;gt; data Person = Person { name :: String, age :: Int } deriving Show
ghci&amp;gt; let person = Person { name = &amp;quot;eiel&amp;quot;, age = 30 }
ghci&amp;gt; person { name = &amp;quot;eielh&amp;quot; }
Person {name = &amp;quot;eielh&amp;quot;, age = 30}
ghci&amp;gt; person { name = &amp;quot;eielh&amp;quot;, age = 20 }
Person {name = &amp;quot;eielh&amp;quot;, age = 20}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;&amp;gt; 突然のハタチ &amp;lt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;特に意味はないが lot を使わない場合。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;ghci&amp;gt; data Person = Person { name :: String, age :: Int } deriving Show
ghci&amp;gt; Person { name = &amp;quot;eiel&amp;quot;, age = 30 } { name = &amp;quot;eielh&amp;quot; }
Person {name = &amp;quot;eielh&amp;quot;, age = 30}
ghci&amp;gt; Person { name = &amp;quot;eiel&amp;quot;, age = 30 } { name = &amp;quot;eielh&amp;quot;, age = 20 }
Person {name = &amp;quot;eielh&amp;quot;, age = 20}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ということはこういうこともできる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;ghci&amp;gt; data Person = Person { name :: String, age :: Int } deriving Show
ghci&amp;gt; Person { name = &amp;quot;eiel&amp;quot;, age = 30 } { name = &amp;quot;eielh&amp;quot; } { age = 20 }
Person {name = &amp;quot;eielh&amp;quot;, age = 20}
ghci&amp;gt; Person { name = &amp;quot;eiel&amp;quot;, age = 30 } { name = &amp;quot;eielh&amp;quot; } { name = &amp;quot;goro&amp;quot; }
Person {name = &amp;quot;goro&amp;quot;, age = 30}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;補足で、ラベルがない場合どうするか。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;ghci&amp;gt; data Person = Person { name :: String, age :: Int } deriving Show
ghci&amp;gt; let person = Person { name = &amp;quot;eiel&amp;quot;, age = 30 }
ghci&amp;gt; case (case person of Person name age -&amp;gt; Person &amp;quot;eielh&amp;quot; age) of Person name age -&amp;gt; Person name 20
Person {name = &amp;quot;eielh&amp;quot;, age = 30}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最適化できるけど、あえてしっかり書いてみる。これはつらい。
というか case 万能すぎ。&lt;/p&gt;

&lt;p&gt;「構造体なんてただの組で、アクセスしやすいようにラベルがついてるだけなんだよ」と言われている気がした。&lt;/p&gt;

&lt;p&gt;あれ?これ、十分&lt;a href=&#34;https://github.com/LTDD/Sessions/wiki&#34;&gt;LT駆動開発&lt;/a&gt;でネタにできた気がする…しまった。&lt;/p&gt;

&lt;h3 id=&#34;参考文献:d941a2b8d40372519c254f53324860b0&#34;&gt;参考文献&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-490003.15&#34;&gt;Haskell 2010 3 Expressions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.sampou.org/haskell/report-revised-j/exps.html&#34;&gt;Haskell 98 Report: 式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;2番目のリンクは山下先生の日本語訳。2010はまだ訳されてない模様。
3.15節からあたり。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Haskell で Selenium</title>
          <link>https://blog.eiel.info/blog/2014/08/25/hs-webdriver/</link>
          <pubDate>Mon, 25 Aug 2014 16:20:00 &#43;0900</pubDate>
          <author>Tomohiko Himura</author>
          <guid>https://blog.eiel.info/blog/2014/08/25/hs-webdriver/</guid>
          <description>&lt;p&gt;たまには Haskell が書きたかったので、コマンドラインからあるウェブサービスに書き込みできるようにしたが失敗した。&lt;/p&gt;

&lt;p&gt;失敗したというか画面を進めていくと止まってしまう。
なにやらアラートがでて処理ができていない感じなのだろうか。
Rubyでやっても停止するので、Haskellの問題ではない。&lt;/p&gt;

&lt;p&gt;一応、最低限の使い方がわかったのでメモしとく。&lt;/p&gt;

&lt;p&gt;利用したのは、&lt;a href=&#34;http://hackage.haskell.org/package/webdriver&#34;&gt;hs-webdriver&lt;/a&gt; と &lt;a href=&#34;http://phantomjs.org/&#34;&gt;phantomJS&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;phantomJS は &amp;ndash;webdriver オプションを使用することで、SeleniumのServerとして使えるようになる。
Haskellでは Selenium と対話するための webdriverというライブラリがあって制御することが可能。&lt;/p&gt;

&lt;p&gt;Google にアクセスしてスクリーンショットを作成するプログラムをかいてみた。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{-# LANGUAGE OverloadedStrings #-}
import Test.WebDriver
import Control.Monad.IO.Class
import qualified Data.ByteString.Lazy.Char8 as B

main :: IO ()
main =
  runSession defaultConfig $ do
    openPage &amp;quot;http://google.co.jp/&amp;quot;
    screenshotWriteFile &amp;quot;google.png&amp;quot;

screenshotWriteFile::  FilePath -&amp;gt; WD ()
screenshotWriteFile name = do
  string &amp;lt;- screenshot
  liftIO . B.writeFile name  $ string
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;事前に&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ phantomjs --webdriver=4444
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としてから実行する。&lt;/p&gt;

&lt;p&gt;実行すると google.png というファイルが生成されている。&lt;/p&gt;

&lt;p&gt;screenshot は ByteString を返すので保存しやすいように screenshotWriteFile という関数を定義して保存しやすくした。
これは webdriver が base64 形式で情報を返してくるのでエンコードした情報を返す模様。&lt;/p&gt;

&lt;p&gt;ブラウザを操作するための関数は&lt;a href=&#34;https://hackage.haskell.org/package/webdriver-0.6.0.1/docs/Test-WebDriver-Commands.html&#34;&gt;Test.WebDriver.Commands&lt;/a&gt;を見ればかいてある。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>LT駆動開発03で「S3にスライドを保存することにした」という発表者をしてきた。</title>
          <link>https://blog.eiel.info/blog/2014/05/03/ltdd-03-s3/</link>
          <pubDate>Sat, 03 May 2014 23:29:00 &#43;0900</pubDate>
          <author>Tomohiko Himura</author>
          <guid>https://blog.eiel.info/blog/2014/05/03/ltdd-03-s3/</guid>
          <description>

&lt;p&gt;&lt;a href=&#34;https://github.com/LTDD/Sessions/wiki/LT%E9%A7%86%E5%8B%95%E9%96%8B%E7%99%BA03&#34;&gt;LT駆動開発03&lt;/a&gt; でLTをしてきました。&lt;/p&gt;

&lt;script async class=&#34;speakerdeck-embed&#34; data-id=&#34;0917d000b4c40131d8ee7625813d8974&#34; data-ratio=&#34;1.33333333333333&#34; src=&#34;//speakerdeck.com/assets/embed.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;最近、本当にSSDの容量不足が深刻で仮想マシンなんて作った日にはさっさと用事を済ませて消さないとやばい状態が続いています。&lt;/p&gt;

&lt;p&gt;そんなわけで、滅多に使うことのないけど、残しておいたら役に立ちそうなファイルはS3に保存してみることにしました。
それだけだとつまらないので、ついでに一般公開しました。&lt;/p&gt;

&lt;p&gt;index.html を作るのに手動で作るのはめんどくさいので、
S3のバケットに保存しているオブジェクトの一覧をAPI経由で取得して、この情報を元に index.html を作成して、アップロードして、静的サイトとして公開しています。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;一覧の取得&lt;/li&gt;
&lt;li&gt;index.html の作成&lt;/li&gt;
&lt;li&gt;index.html のアップロード&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;を自動化しています。&lt;/p&gt;

&lt;p&gt;実際のページとソースコードはこちらに。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://keynotes.eiel.info/&#34;&gt;http://keynotes.eiel.info/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/eiel/keynotes-eiel&#34;&gt;GitHub - eiel/keynotes-eiel&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;S3を使った静的サイトの運用もちょっと試してみたかったので良い機会でした。まだ、調査が必要そうですけども。&lt;/p&gt;

&lt;p&gt;自動化はしていない部分であるスライドのアップロードには &lt;a href=&#34;http://s3tools.org/s3cmd&#34;&gt;s3cmd&lt;/a&gt; を利用しています。&lt;/p&gt;

&lt;p&gt;後半はHaskellの話です。
HaskellのAWSのAPIを叩くには &lt;a href=&#34;https://hackage.haskell.org/package/aws&#34;&gt;aws&lt;/a&gt; ライブラリを使用しました。他にも &lt;a href=&#34;https://hackage.haskell.org/package/aws-sdk&#34;&gt;aws-sdk&lt;/a&gt; というライブラリもあるようですが、対応しているサービスが違っているようでした。&lt;/p&gt;

&lt;p&gt;元々 Ruby を使ってつくってたのですが、なんとなく理由もなく Haskell でやりたくなってHaskellでやってみましたが、意外と簡単にできました。
Haskell 良いですね。&lt;/p&gt;

&lt;p&gt;あとレコード型が実に使いこなせてないことに気づいたので勉強してこようと思いました。&lt;/p&gt;

&lt;p&gt;まだ、 keynotes.eiel.info に特化しているのでそのうち汎用性を上げたいと思います。&lt;/p&gt;

&lt;p&gt;スライドですが、&lt;a href=&#34;http://memo.sanographix.net/post/82160791768&#34;&gt;azusa テンプレート&lt;/a&gt;をかなり参考にさせていただきました。
というか、色は少し自分好みに変えただけですね。
赤はもうちょっと明るい色を使うほうがいいなって思う反省点がありました。&lt;/p&gt;

&lt;p&gt;そんなわけで、今日はこの辺で。&lt;/p&gt;

&lt;h3 id=&#34;関連リンク:b3783079e786d24bd78477f1a8b31e09&#34;&gt;関連リンク&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.eiel.info/blog/2014/02/19/start-ltdd/&#34;&gt;LT駆動開発という勉強会をはじめるよ - そんなこと覚えてない&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
      
    
      
        <item>
          <title>手軽にHaskell できる hawk が楽しい</title>
          <link>https://blog.eiel.info/blog/2014/02/14/hawk/</link>
          <pubDate>Fri, 14 Feb 2014 21:34:00 &#43;0900</pubDate>
          <author>Tomohiko Himura</author>
          <guid>https://blog.eiel.info/blog/2014/02/14/hawk/</guid>
          <description>&lt;p&gt;コマンドラインで Haskell のワンライナーっぽいものが使える &lt;a href=&#34;https://github.com/gelisam/hawk&#34;&gt;hawk&lt;/a&gt; ってのがあるらしくて、awk に似ているから hawk っていうらしい。&lt;/p&gt;

&lt;p&gt;気軽に Haskell の練習できて楽しい。&lt;/p&gt;

&lt;p&gt;インストールは&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cabal install haskell-awk
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;らしい。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hoge:goro:mogu
goro:mogu:hoge
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;という入力があって 2列目だけ取り出したーいとかなら&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ echo &amp;quot;hoge:goro:mogu\ngoro:mogu:hoge&amp;quot; | hawk -d: -m &#39;!!2&#39;
mogu
hoge
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;という感じらしい。-m を使うと行ごとの処理がかけて -d を使うとデリミタを認識してあらかじめリストしておいてくれる。&lt;/p&gt;

&lt;p&gt;それ意外にも情報源にできる。&lt;/p&gt;

&lt;p&gt;奇数のリストを作って10個とりだしてみる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$  hawk &#39;take 10 [1,3..]&#39;
1
3
5
7
9
11
13
15
17
19
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;もちろん無限リストだって作れる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hawk &#39;[1,3..]&#39; | head -n 10
1
3
5
7
9
11
13
15
17
19
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;~/.hawk/prelude.hs&lt;/code&gt; をいじれば、他のモジュールもインポートできる。&lt;/p&gt;

&lt;p&gt;Data.Ix でも追加して遊んでみる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;{-# LANGUAGE ExtendedDefaultRules, OverloadedStrings #-}
import Prelude
import qualified Data.ByteString.Lazy.Char8 as B
import qualified Data.List as L
import Data.Ix
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ hawk &#39;range ((0,0,0),(2,2,2))&#39; | head -n 20
0 0 0
0 0 1
0 0 2
0 1 0
0 1 1
0 1 2
0 2 0
0 2 1
0 2 2
1 0 0
1 0 1
1 0 2
1 1 0
1 1 1
1 1 2
1 2 0
1 2 1
1 2 2
2 0 0
2 0 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ひっくくりかえして&lt;/code&gt;、 &lt;code&gt;3つとる&lt;/code&gt;とかを愚直にかくと、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ seq 10 | hawk -a &#39;take 3 . reverse&#39;
10
9
8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;でやりたい順番と逆転してしまうので、 &lt;code&gt;~/.hawk/prelude.hs&lt;/code&gt; に &lt;code&gt;import Control.Arrow&lt;/code&gt; 追加しときました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ seq 10 | hawk -a &#39;reverse &amp;gt;&amp;gt;&amp;gt; take 3&#39;
10
9
8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なんとなく楽しい。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>そういえば彼氏募集というネタリポジトリがありましたね。真似するならこんな感じかなぁ。</title>
          <link>https://blog.eiel.info/blog/2014/02/08/i-need-a-girlfriend/</link>
          <pubDate>Sat, 08 Feb 2014 17:19:00 &#43;0900</pubDate>
          <author>Tomohiko Himura</author>
          <guid>https://blog.eiel.info/blog/2014/02/08/i-need-a-girlfriend/</guid>
          <description>

&lt;p&gt;最近、C++界や、ひろし魔界で暴れているらしい&lt;a href=&#34;https://twitter.com/PG_nonen&#34;&gt;まさかず氏&lt;/a&gt;が&lt;a href=&#34;https://github.com/norinori2222/boyfriend_require&#34;&gt;彼氏募集のリポジトリ&lt;/a&gt;を真似して&lt;a href=&#34;https://github.com/minamiyama1994/girlfriend_require&#34;&gt;彼女募集のリポジトリ&lt;/a&gt;を作成してました。&lt;/p&gt;

&lt;p&gt;条件さえ揃えば真似してもよかったのですが、条件が揃ってなかったので真似してませんでした。
気がついたら条件が揃ってたので真似してみることにしてみました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/eiel/need_a_girlfriend&#34;&gt;﻿eiel/need_a_girlfriend - GitHub&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;やったこと&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;fork したけど 空のブランチつくって、fork元とはコード的には関係をなくした&lt;/li&gt;
&lt;li&gt;Haskell で DSL したかった。結局、Writer モナドの上に構築した。&lt;/li&gt;
&lt;li&gt;source ブランチを push すると travis で &lt;code&gt;README.md&lt;/code&gt; を生成して master ブランチに自動で push する&lt;/li&gt;
&lt;li&gt;リポジトリの名前を変更した&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;fork-したけど-空のブランチつくって-fork元とはコード的には関係をなくした:a0a1f37e986eb43a89ced5b8b8d20f10&#34;&gt;fork したけど 空のブランチつくって、fork元とはコード的には関係をなくした&lt;/h3&gt;

&lt;p&gt;fork したので、その上から上書きしてもよかったのですが、だいぶ違うし、ゼロからつくりたいけど fork したことは残したいよね。&lt;/p&gt;

&lt;p&gt;ということで空のブランチをつくってから作りました。
&lt;code&gt;git checkout --orphan &amp;lt;branch名&amp;gt;&lt;/code&gt; で空のブランチが作れます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.eiel.info/images/2014-02-08-network.png&#34; alt=&#34;ネットワーク&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;haskell-で-dsl-したかった:a0a1f37e986eb43a89ced5b8b8d20f10&#34;&gt;Haskell で DSL したかった。&lt;/h3&gt;

&lt;p&gt;README.md は手書きせずにプログラムから生成するようにしてみました。
&lt;a href=&#34;https://twitter.com/PG_nonen&#34;&gt;まさかず氏&lt;/a&gt;を真似ただけである。&lt;/p&gt;

&lt;p&gt;Haskell で DSL 作るのにはどうしたらいいんだろうなぁ。たぶんモナド作ればいいんだろうと、コード書きはじめたけど、途中でよくわからなくなった。
それはそれで別に勉強すればいいやということから途中から Writer モナドでつくりました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;background = do
  h1 &#39;背景&#39;
  p &#39;ほげほげごろごろ&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;みたいに書きたかった。というか、このように書いてから h1 や p 関数を実装しました。&lt;/p&gt;

&lt;p&gt;Writer モナド は tell 関数を呼びだしておくと、 runWriter した時に最終結果と tell した内容が引き出せるようです。&lt;/p&gt;

&lt;p&gt;上記の例だと以下のような値が返るように作ってます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;((),[&amp;quot;# &amp;quot;,&amp;quot;背景&amp;quot;,&amp;quot;\n&amp;quot;,&amp;quot;\n&amp;quot;,&amp;quot;ほげほげごろごろ&amp;quot;,&amp;quot;\n&amp;quot;,&amp;quot;\n&amp;quot;])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あとはリストの内容を標準出力に書きだしました。
リストを後ろにくっつけていくからパフォーマンスがなんか気になるけどどうなんだろう。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/eiel/need_a_girlfriend/blob/master/need_a_girlfriend.hs&#34;&gt;あとはコードでも見てください。&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Writer モナド書き換える際、main関数は &lt;a href=&#34;https://github.com/eiel/need_a_girlfriend/blob/master/need_a_girlfriend.hs#L3&#34;&gt;&lt;code&gt;runWriter&lt;/code&gt;&lt;/a&gt; の部分をちょっと書き換えたかなーぐらいなものでモナドの使いやすさを感じたような気がします。&lt;/p&gt;

&lt;h3 id=&#34;source-ブランチを-push-すると-travis-で-reame-md-を生成して-master-ブランチに自動で-push-する:a0a1f37e986eb43a89ced5b8b8d20f10&#34;&gt;source ブランチを push すると travis で &lt;code&gt;REAME.md&lt;/code&gt; を生成して master ブランチに自動で push する&lt;/h3&gt;

&lt;p&gt;基本的には&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://tricknotes.hateblo.jp/entry/2013/06/17/020229&#34;&gt;Middleman で作った web サイトを Travis + GitHub pages でお手軽に運用する - tricknotesのぼうけんのしょ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;を参考にしました。他の方法も試したけどなかなか手強いので結局この方法にしました。&lt;/p&gt;

&lt;p&gt;手順的には travis 上でリポジトリを選択して、処理を &lt;code&gt;.travis.yml&lt;/code&gt;を記述します。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;.travis.yml&lt;/code&gt; に書いた処理の最後で push しますが、 &lt;code&gt;-q&lt;/code&gt; やら &lt;code&gt;2&amp;gt;/dev/null&lt;/code&gt; がついてるせいでなんで失敗してるのか気づきにくいのがちょっと難点でした。
つけないと TORKEN が漏れてしまう。&lt;/p&gt;

&lt;p&gt;参考程度に書いた yaml を貼っておきます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;language: haskell
install: cabal install mtl
script: ghc need_a_girlfriend.hs
after_success:
  - git remote add deploy https://$GH_TOKEN@github.com/eiel/need_a_girlfriend.git
  - git fetch deploy master
  - git checkout master
  - git merge source --no-edit
  - ./need_a_girlfriend &amp;gt; README.md
  - git add README.md
  - &#39;git commit -m &amp;quot;Generate Travis JOB $TRAVIS_JOB_NUMBER

https://travis-ci.org/eiel/need_a_girlfriend/builds/$TRAVIS_BUILD_ID&amp;quot;&#39;
  - &#39;[ &amp;quot;x$TRAVIS_BRANCH&amp;quot; == &amp;quot;xsource&amp;quot; ] &amp;amp;&amp;amp; git push -q deploy master 2&amp;gt;/dev/null&#39;
branches:
  except:
    - master
env:
  global:
    - secure: &amp;quot;KJG63ZK8zdEboimt/+UOVDUu+cECmvSgsCyEUEQVjMnazxpEaNQbP+lEQv9TWki6eRtr71+vt3LU7H4H8Wm/jURV2WiYe31ZeE7wvRcjjaHRWHYfeTJ5OyBJhCJoauKBAwL/jIFSTDt3IEgGIW42WPwagGexHKm+Vh/0ETK1CNc=&amp;quot;
    - GIT_COMMITTER_NAME=&amp;quot;name&amp;quot;
    - GIT_COMMITTER_EMAIL=&amp;quot;email@example.com&amp;quot;
    - GIT_AUTHOR_NAME=&amp;quot;name&amp;quot;
    - GIT_AUTHOR_EMAIL=&amp;quot;email@example.com&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;after_success が script の実行に成功した場合に実行されます。&lt;/p&gt;

&lt;p&gt;source ブランチの時にしか push しないような処理をいれてあります。
master ブランチの際は after_success がそもそも走らないようにしています。&lt;/p&gt;

&lt;p&gt;コミットメッセージを作るのに環境変数から情報を得ています。
どんな環境変数があるかは&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.travis-ci.com/user/ci-environment/&#34;&gt;Travis CI: The Build Environment&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;に書いてあります。
環境変数は travis の画面上では展開しない仕様になってるみたいです。&lt;/p&gt;

&lt;p&gt;その他の参考文献&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.travis-ci.com/user/languages/haskell/&#34;&gt;Travis CI: Building a Haskell Project&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.travis-ci.com/user/deployment/custom/&#34;&gt;Travis CI: Custom Deployment&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;リポジトリの名前を変更した:a0a1f37e986eb43a89ced5b8b8d20f10&#34;&gt;リポジトリの名前を変更した&lt;/h3&gt;

&lt;p&gt;「require ってなんか違う気がするんだよなー」って感覚がしたので調べたら一般的には I need a boyfriend とか I need a girlfriend と書いてる例があったので、リポジトリ名は need_a_girlfriend にしました。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;eiel / need_a_girlfriend&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;となるので、なんか文法的にも良さげな気がします。&lt;/p&gt;

&lt;h3 id=&#34;まとめ:a0a1f37e986eb43a89ced5b8b8d20f10&#34;&gt;まとめ&lt;/h3&gt;

&lt;p&gt;しかし、元のリポジトリの条件の多さにはびっくりする。
お互い悪いところは相性みながらちょっとづつ調整できないものなのでしょうか。
これだけは譲れないものはひとつかふたくぐらいあれば充分じゃないんでしょうか。
私にはよくわからないですけど。&lt;/p&gt;

&lt;p&gt;日々、成長するのを放棄した人間にはなりたくないかなぁ。&lt;/p&gt;

&lt;p&gt;そんなことはともかく&lt;a href=&#34;https://twitter.com/PG_nonen&#34;&gt;まさかず氏&lt;/a&gt;はすごくがんばっていると思うので素敵な彼女ができるように応援したいですね。&lt;/p&gt;

&lt;p&gt;ではでは。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>流れるようにプログラミングしたい - 合同勉強会 in 大都会岡山 2013 Winter</title>
          <link>https://blog.eiel.info/blog/2013/12/15/gbdaitokai-2013/</link>
          <pubDate>Sun, 15 Dec 2013 01:38:00 &#43;0900</pubDate>
          <author>Tomohiko Himura</author>
          <guid>https://blog.eiel.info/blog/2013/12/15/gbdaitokai-2013/</guid>
          <description>

&lt;p&gt;&lt;a href=&#34;http://gbdaitokai.doorkeeper.jp/events/5725&#34;&gt;合同勉強会 in 大都会岡山 -2013 Winter-&lt;/a&gt; でライトニングトークをしました。&lt;/p&gt;

&lt;p&gt;合同勉強会という名前からわかるように各勉強会からいろんなスピーカーがやってきて、セッションをします。
私は&lt;a href=&#34;http://hiroshimarb.github.io/&#34;&gt;Hiroshima.rb&lt;/a&gt;・&lt;a href=&#34;http://great-h.github.io/&#34;&gt;すごい広島&lt;/a&gt;・&lt;a href=&#34;http://webtouchmeeting.com/&#34;&gt;WEB TOUCH MEETING&lt;/a&gt; からやってきたという形でライトニングトークをしました。&lt;/p&gt;

&lt;script async class=&#34;speakerdeck-embed&#34; data-id=&#34;82c04820470b0131b3441e6594d9299f&#34; data-ratio=&#34;1.33333333333333&#34; src=&#34;//speakerdeck.com/assets/embed.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;「流れるようにプログラミングしたい」というタイトルです。
Ruby で読み書きしやすいプログラミングをしたときの問題点を紹介しつつ、Haskell の良いところを紹介するといった内容です。
内容も多かったのでかなりの早口で喋りました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://gist.github.com/eiel/7956834&#34;&gt;コードはこちらら&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ruby で関数型の思考でプログラミングをすると自然と流れるようなコードになりますが、問題があり、データをすべて読み終えないとプログラムが実行されないという状態になります。&lt;/p&gt;

&lt;p&gt;その例が flow.rb のプログラムです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;puts ARGF.each_line
  .map(&amp;amp;:to_i)            # 数値に
  .map { |n| n * 5}       # 5倍する
  .select { |n| n &amp;gt; 10 }  # 10より大きいものだけに
  .first(5)               # 最初の5つ
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Haskell を使用した場合は、そのまま書いてもこの問題はおきず、現時点で処理できる時点まで処理してくれています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;main = do
  getContents &amp;gt;&amp;gt;= (
    return .
    take 5 .        -- 最初の5個
    filter (&amp;gt;10) .  -- 10より大きいものだけに
    map (*5) .      -- 5倍する
    map read .      -- 数値に
    lines
    ) &amp;gt;&amp;gt;= mapM_ print
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;しかし、Haskell の場合はコードの順番と実行の順番が逆転してしまいます。&lt;/p&gt;

&lt;p&gt;Haskell をつかわなくても ruby 2.0 以降標準添付された Enumerator::Lazy を使うとこの問題は解決できます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ARGF.each_line
  .lazy
  .map(&amp;amp;:to_i)             # 数値に
  .map { |n| n * 5 }       # 5倍する
  .select { |n| n &amp;gt; 10 }   # 10より大きいものだけに
  .map { |n| puts n }      # 出力
  .first(5)                # 最初の5個
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この lazy はなかなか一筋縄にはいかなくて、出力も map でやらなければならなく、純粋さを追求すると気持ち悪いです。&lt;/p&gt;

&lt;p&gt;Haskell の問題である順番が逆転してしまう問題は Control.Arrow を利用すると解決できます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;main = getContents &amp;gt;&amp;gt;= (
  lines
  &amp;gt;&amp;gt;&amp;gt; map read       -- 数値に変換
  &amp;gt;&amp;gt;&amp;gt; map (*5)       -- 5倍する
  &amp;gt;&amp;gt;&amp;gt; filter (&amp;gt;10)   -- 10より大きいものだけに
  &amp;gt;&amp;gt;&amp;gt; take 5         -- 最初の5個
  &amp;gt;&amp;gt;&amp;gt; return
  ) &amp;gt;&amp;gt;= mapM_ print
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これでちゃんと、順番どおりによむことができます。&lt;/p&gt;

&lt;h3 id=&#34;まとめ:d4aa6e878fc09181c48be7c1505e8838&#34;&gt;まとめ&lt;/h3&gt;

&lt;p&gt;Arrow の部分はおまけにすぎないですが、感動した部分であったり、関数型の思考で Ruby を書いた場合は効率という点で気になる部分もあり Haskell 面白いと思った部分です。&lt;/p&gt;

&lt;p&gt;その部分を無理矢理5分で話したのでかなり早口だったり、私自身の息が上がったりして少し迷惑をおかけしました。&lt;/p&gt;

&lt;p&gt;笑いもとれていたようなので、その点はよかったです。&lt;/p&gt;

&lt;p&gt;ByteString や Text をつかった場合、どうなるのか確認しておきたいなぁ。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>広島Ruby勉強会 #031 で 「Hakyllで遊んだ」のでざくっと紹介した。</title>
          <link>https://blog.eiel.info/blog/2013/04/07/hiroshimarb-31/</link>
          <pubDate>Sun, 07 Apr 2013 01:00:00 &#43;0900</pubDate>
          <author>Tomohiko Himura</author>
          <guid>https://blog.eiel.info/blog/2013/04/07/hiroshimarb-31/</guid>
          <description>&lt;p&gt;&lt;a href=&#34;http://hiroshimarb.github.io/blog/2013/04/06/hiroshimarb-31/&#34;&gt;広島Ruby勉強会 #031&lt;/a&gt; で かるくLT しました。&lt;/p&gt;

&lt;p&gt;内容は &lt;a href=&#34;http://jaspervdj.be/hakyll/&#34;&gt;Hakyll&lt;/a&gt; についてです。&lt;/p&gt;

&lt;p&gt;なのですが、Rubyのリファレンスからメソッドの紹介をしているのですが、今回は ActiveSupport で追加される メソッド。Array 編をしました。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://railsdoc.eiel.info/&#34;&gt;その資料はこちらに。&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;この資料をどこにどうやって置こうかな？と思っていたので、ついでにHakyllを試してみました。そこで学んだこととかを紹介しました。&lt;/p&gt;

&lt;p&gt;&lt;iframe src=&#34;http://www.slideshare.net/slideshow/embed_code/18303056&#34; width=&#34;427&#34; height=&#34;356&#34; frameborder=&#34;0&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34; style=&#34;border:1px solid #CCC;border-width:1px 1px 0;margin-bottom:5px&#34; allowfullscreen webkitallowfullscreen mozallowfullscreen&gt; &lt;/iframe&gt; &lt;div style=&#34;margin-bottom:5px&#34;&gt; &lt;strong&gt; &lt;a href=&#34;http://www.slideshare.net/TomohikoHimura/hakyll-18303056&#34; title=&#34;Hakyllで遊んでみた。&#34; target=&#34;_blank&#34;&gt;Hakyllで遊んでみた。&lt;/a&gt; &lt;/strong&gt; from &lt;strong&gt;&lt;a href=&#34;http://www.slideshare.net/TomohikoHimura&#34; target=&#34;_blank&#34;&gt;Tomohiko Himura&lt;/a&gt;&lt;/strong&gt; &lt;/div&gt;&lt;/p&gt;

&lt;p&gt;このサイトのソースコードは &lt;a href=&#34;https://github.com/eiel/railsdoc.eiel.info&#34;&gt;Github&lt;/a&gt; に丸投げしていたりします。&lt;/p&gt;

&lt;p&gt;このスライドに書いてないことでは、コンパイルを毎回するのがめんどくさかったので、ghci から 引数付きで main 関数を実行する方法を調べました。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;System.Environment&lt;/code&gt; に定義されてる &lt;code&gt;withArgs&lt;/code&gt; を使えばできました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;withArgs :: [String] -&amp;gt; IO a -&amp;gt; IO a&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;利用例:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;withArgs [&amp;quot;build&amp;quot;] main
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第1引数にコマンド引数をリストで渡してしまえば、良いようです。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>よりよい開発者になるために CodeKata</title>
          <link>https://blog.eiel.info/blog/2013/02/13/codekata/</link>
          <pubDate>Wed, 13 Feb 2013 16:08:00 &#43;0900</pubDate>
          <author>Tomohiko Himura</author>
          <guid>https://blog.eiel.info/blog/2013/02/13/codekata/</guid>
          <description>&lt;p&gt;github の News Feed みてたら codekata というのがあって、なんだっけと思いつつ調べたら&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;情熱プログラマという本 （ &lt;a href=&#34;http://amzn.to/d6zjDE&#34;&gt;http://amzn.to/d6zjDE&lt;/a&gt; ) を読んでいる。&lt;/p&gt;

&lt;p&gt;そこにこんなことが書いてあった。&lt;/p&gt;

&lt;p&gt;プログラマはしばしば実務の中でスキルを訓練する。
これがミュージシャンだったらどうだろう？ 彼らがステージ上で変な音を出しながら練習していたら、観客はどう思う？ 練習は、観客のいない密室で、自分の時間を使ってするべきだ。プログラマもそれと同じだ。&lt;/p&gt;

&lt;p&gt;なるほど、それはその通りだ。で、この本にプログラミングの訓練の手がかりが紹介されている。
それが「Code Kata ( &lt;a href=&#34;http://codekata.pragprog.com/&#34;&gt;http://codekata.pragprog.com/&lt;/a&gt; )」 だ。&lt;/p&gt;

&lt;p&gt;&amp;ldquo;Kata&amp;rdquo;とは、空手の型のこと。
空手の練習は、定められた型を繰り返し反復することで技術を習得していく。
それと同様のコンセプトで、型を訓練し、ソフトウェア開発のスキルを磨きましょう、というものだそうな。&lt;/p&gt;

&lt;p&gt;&lt;small&gt;&amp;ndash; 言葉をポッケに持ち歩こう&lt;/small&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;なるほど。日々の基礎練習が大切なんですね。&lt;/p&gt;

&lt;p&gt;ということで forkして &lt;a href=&#34;https://github.com/eiel/haskell_codekata&#34;&gt;codekata for haskell&lt;/a&gt; はじめました。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>読書メモ 関数プログラミング入門 Haskellで学ぶ原理と技法 1.7 仕様</title>
          <link>https://blog.eiel.info/blog/2013/02/12/intro-functional-1-dot-7/</link>
          <pubDate>Tue, 12 Feb 2013 23:33:00 &#43;0900</pubDate>
          <author>Tomohiko Himura</author>
          <guid>https://blog.eiel.info/blog/2013/02/12/intro-functional-1-dot-7/</guid>
          <description>

&lt;p&gt;&lt;a href=&#34;http://www.amazon.co.jp/gp/product/427406896X/ref=as_li_ss_tl?ie=UTF8&amp;amp;camp=247&amp;amp;creative=7399&amp;amp;creativeASIN=427406896X&amp;amp;linkCode=as2&amp;amp;tag=eiel-22&#34;&gt;関数プログラミング入門 Haskell で学ぶ原理と技法&lt;/a&gt; の読書メモです。引用もしていますし、感想なども混ぜています。&lt;/p&gt;

&lt;p&gt;本節は&lt;strong&gt;仕様&lt;/strong&gt;についてです。&lt;/p&gt;

&lt;p&gt;仕様と実装の関係について、語られます。
仕様はやりたいこと、実装は実現方法。
そんな感じのことがかかれています。&lt;/p&gt;

&lt;p&gt;関数の仕様を表明し、そのやりかたとして引数と戻り値の組を用意する。
単純な実装を行い、よりよい実装にしていく方法が良いとされてます。&lt;/p&gt;

&lt;p&gt;すごくBDD感漂うRspec的な手法が勧められていますね。&lt;/p&gt;

&lt;p&gt;この手法の難しい点は、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;仕様が利用者の要求とずれてしまうかも。&lt;/li&gt;
&lt;li&gt;仕様を満たすための検証が膨大になりすぎて証明が大変&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ということです。非常に身に覚えがあります。&lt;/p&gt;

&lt;h2 id=&#34;練習問題:e7079363f43b9581a2da49b8823b543f&#34;&gt;練習問題&lt;/h2&gt;

&lt;p&gt;あまりおもしろくない解答をかきました。うーん。面白いの考えたい。&lt;/p&gt;

&lt;h2 id=&#34;ついでに1章のまとめ:e7079363f43b9581a2da49b8823b543f&#34;&gt;ついでに1章のまとめ。&lt;/h2&gt;

&lt;p&gt;一度、読書メモを本気でやってみようと思っていたのではじめてみましたが、思うよりもずっとずっと大変でしたが、関数プログラミングに対する基礎知識がグッと固いものになったと感じてます。&lt;/p&gt;

&lt;p&gt;通し読みせずにやっているので、読み終わるのはいつになるのでしょうか。&lt;/p&gt;

&lt;p&gt;これからもがんばってできる限り続けていきたいです。&lt;/p&gt;

&lt;h2 id=&#34;関連:e7079363f43b9581a2da49b8823b543f&#34;&gt;関連&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/eiel/Introduction-to-Functional-Programming-using-Haskell/blob/master/1/index.org&#34;&gt;メモ用のリポジトリ 1章&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/eiel/Introduction-to-Functional-Programming-using-Haskell/blob/master/1/1.7.hs&#34;&gt;1.6の練習問題&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
      
    
      
        <item>
          <title>読書メモ 関数プログラミング入門 Haskellで学ぶ原理と技法 1.6 仕様</title>
          <link>https://blog.eiel.info/blog/2013/02/11/intro-functional-1-dot-6/</link>
          <pubDate>Mon, 11 Feb 2013 16:11:00 &#43;0900</pubDate>
          <author>Tomohiko Himura</author>
          <guid>https://blog.eiel.info/blog/2013/02/11/intro-functional-1-dot-6/</guid>
          <description>

&lt;p&gt;&lt;a href=&#34;http://www.amazon.co.jp/gp/product/427406896X/ref=as_li_ss_tl?ie=UTF8&amp;amp;camp=247&amp;amp;creative=7399&amp;amp;creativeASIN=427406896X&amp;amp;linkCode=as2&amp;amp;tag=eiel-22&#34;&gt;関数プログラミング入門 Haskell で学ぶ原理と技法&lt;/a&gt; の読書メモです。引用もしていますし、感想なども混ぜています。&lt;/p&gt;

&lt;p&gt;本節は&lt;strong&gt;型&lt;/strong&gt;についてです。強い型付けがよくわからなくて悩みました。&lt;/p&gt;

&lt;p&gt;内容は&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;型の基本と強い型付け&lt;/li&gt;
&lt;li&gt;多相型&lt;/li&gt;
&lt;li&gt;型クラス&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;といった感じです&lt;/p&gt;

&lt;h2 id=&#34;型の基本と強い型付け:af683e4c3eedf289586ccacebb20a44c&#34;&gt;型の基本と強い型付け&lt;/h2&gt;

&lt;p&gt;値は型という集まりに分類することができて、様々な型があります。 &lt;code&gt;Int&lt;/code&gt;, &lt;code&gt;Float&lt;/code&gt;, &lt;code&gt;Integer&lt;/code&gt;,リスト…などなど。&lt;/p&gt;

&lt;p&gt;既存の型を組合せて新しい型も作れます。 &lt;code&gt;(Int, Int)&lt;/code&gt;, &lt;code&gt;Int -&amp;gt; Int&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;型固有に演算があり、違う型に利用することは無意味です。意味がないので不当な式となります。&lt;/p&gt;

&lt;p&gt;式であれば、必ず型があり、その型は式を構成する要素から推論できます。構成要素から型が決定できるので強い型付けになるようです。(ここがはっきりしなくて悩んだ)
弱い型つけの場合は暗黙のキャストなどにより実行してみないとわからない部分があるようです。&lt;/p&gt;

&lt;p&gt;強い型付けの利点は&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;つづりミスや混乱した定義をコンパイル時点で発見できる&lt;/li&gt;
&lt;li&gt;プログラムを書く際のルールになる&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;だそうです。&lt;/p&gt;

&lt;p&gt;引数や結果の型を考えることで型レベルの整合性を保ち、その中で値をやりくりするので、型の枠から外れることも防ぐことができて、明瞭なプログラム設計ができるようです。&lt;/p&gt;

&lt;h2 id=&#34;多相型:af683e4c3eedf289586ccacebb20a44c&#34;&gt;多相型&lt;/h2&gt;

&lt;p&gt;式の型は 構成要素から決定できますが、関数合成や和や積などは複数の型に対して利用できているように見えます。これは型変数を利用することでこのような定義ができます。&lt;/p&gt;

&lt;p&gt;「それって強い型付けなの？」という疑問に教われるのですが、型変数を含んでいても型なので問題がないようです。
曖昧であれば不正な式になるのだと思います。その場合は推論に任せず型指定をすることになります。&lt;/p&gt;

&lt;p&gt;このように型変数を含む型を多相型と呼びます。&lt;/p&gt;

&lt;p&gt;おまけで (-&amp;gt;) は 型演算子 だそうで、右結合だそうです。&lt;code&gt;Int -&amp;gt; Int&lt;/code&gt; は &lt;code&gt;-&amp;gt;&lt;/code&gt; で演算して新しい型を作るとも言えます。
型式というものがありそうですが説明されてません。&lt;/p&gt;

&lt;h2 id=&#34;型クラス:af683e4c3eedf289586ccacebb20a44c&#34;&gt;型クラス&lt;/h2&gt;

&lt;p&gt;和や積をするつあめの &lt;code&gt;(+)&lt;/code&gt;, &lt;code&gt;(*)&lt;/code&gt; がありますがこれを型変数で定義するには一般的すぎます。数値であるようなものであれば扱えて欲しい。
そのような似た型をまとめる型クラスという機能があります。型変数に制約をつけることができます。数値であるような型は Num クラスのインスタンスとなります。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Num a =&amp;gt; a -&amp;gt; a -&amp;gt; a&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;とかいたとき&lt;/p&gt;

&lt;p&gt;&lt;code&gt;a がNumクラスのインスタンスであるという制約のもとで、 a -&amp;gt; a -&amp;gt; a&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;と、読みます。&lt;/p&gt;

&lt;p&gt;数値以外の型クラスに 値が表示可能な型クラス(Show) 相等性検査可能な型クラス(Eq) 列挙可能な型(Enum) などなど様々なクラスがあります。(モナドとか)&lt;/p&gt;

&lt;p&gt;ある型は複数の型クラスのインスタンスになれます。
なんだかレイヤーがひとつ違う感じですね。&lt;/p&gt;

&lt;h2 id=&#34;練習問題:af683e4c3eedf289586ccacebb20a44c&#34;&gt;練習問題&lt;/h2&gt;

&lt;p&gt;lhs 形式を選択したのですが、あまり意味がありませんでした。
lhs 形式は地の文がコメントになり &lt;code&gt;&amp;gt;&lt;/code&gt; ではじまる部分がHaskellのコードになります。&lt;/p&gt;

&lt;h2 id=&#34;まとめ:af683e4c3eedf289586ccacebb20a44c&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;型システムへの理解不足で難しかったです。
なんとなくで理解していたところだいぶすっきりすることができました。&lt;/p&gt;

&lt;p&gt;型を意識することで、他のプログラミング言語を利用する場合にも明瞭な設計ができると思います。&lt;/p&gt;

&lt;h2 id=&#34;関連:af683e4c3eedf289586ccacebb20a44c&#34;&gt;関連&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/eiel/Introduction-to-Functional-Programming-using-Haskell/blob/master/1/index.org&#34;&gt;メモ用のリポジトリ 1章&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/eiel/Introduction-to-Functional-Programming-using-Haskell/blob/master/1/1.6.lhs&#34;&gt;1.6の練習問題&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
      
    
      
        <item>
          <title>@souda1025 に PythonでFizzBuzzとかしてみた に対抗しろって煽られたので。</title>
          <link>https://blog.eiel.info/blog/2013/01/26/soudai-fizzbuzz/</link>
          <pubDate>Sat, 26 Jan 2013 14:33:00 &#43;0900</pubDate>
          <author>Tomohiko Himura</author>
          <guid>https://blog.eiel.info/blog/2013/01/26/soudai-fizzbuzz/</guid>
          <description>

&lt;p&gt;&lt;a href=&#34;http://twitter.com/soudai1025&#34;&gt;@soudai1025&lt;/a&gt; が書いた&lt;a href=&#34;http://soudai1025.blogspot.jp/2013/01/pythonfizzbuzz.html?spref=fb&#34;&gt;ブログ記事にPythonでFizzBuzzとかしてみた&lt;/a&gt;というエントリーがあるのですが、Facebookでこういうコメントをみた。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;多分、ひむひむが対抗してくるはず。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;全力でお答えしましょう。&lt;/p&gt;

&lt;p&gt;とりあえず、普通 FizzBuzz かくならこうかくだろう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def fizzbuzz(number):
    if number % 15 == 0:  # number % 5 == 0 and number % 3 == 0
        return &amp;quot;FizzBuzz&amp;quot;
    elif number % 5 == 0:
        return &amp;quot;Buzz&amp;quot;
    elif number % 3 == 0:
        return &amp;quot;Fizz&amp;quot;
    else:
        return str(number)

if __name__ == &#39;__main__&#39;:
    number = int(raw_input(&amp;quot;Please enter an integer: &amp;quot;))
    print fizzbuzz(number)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;数値を入れると &lt;code&gt;数値の文字列&lt;/code&gt; か &amp;ldquo;Fizz&amp;rdquo; か &amp;ldquo;Buzz&amp;rdquo; か &amp;ldquo;FizzBuzz&amp;rdquo; を返す関数を用意するほうが柔軟性があり、わかりやすいです。&lt;/p&gt;

&lt;p&gt;さて、もとのコードを確認していきましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;int = int(raw_input(&amp;quot;Please enter an integer: &amp;quot;))

def do_fizz(int):
    if (int % 3) == 0:
        return 1
    return 0

def do_buzz(int):
    if (int % 5) == 0:
        return 2
    return 0

def do_answer(fizz, buzz):
    flag = fizz + buzz
    if flag == 0:
        print int #引数に居なくても外のintを参照出来る
    elif flag == 1:
        print &amp;quot;Fizz&amp;quot;
    elif flag == 2:
        print &amp;quot;Buzz&amp;quot;
    elif flag == 3:
        print &amp;quot;FizzBuzz&amp;quot;

do_answer(do_fizz(int), do_buzz(int))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、気になる点をあげていこう。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;do_answer&lt;/code&gt; 関数が外のスコープにアクセスしている。&lt;/li&gt;
&lt;li&gt;よくわからないフラグ処理がされている。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;do_answer&lt;/code&gt; の引数が意味不明。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;関数が外のスコープにアクセスしている:aa533cc5bfd0e8e446ea5505e1815d9f&#34;&gt;関数が外のスコープにアクセスしている&lt;/h2&gt;

&lt;p&gt;関数が外のスコープにアクセスしてしまうとその関数だけみたときに他の部分を確認しないといけないのでよくない。&lt;/p&gt;

&lt;p&gt;それぐらいなら引数を追加しましょう。&lt;/p&gt;

&lt;h2 id=&#34;よくわからないフラグ処理がされている:aa533cc5bfd0e8e446ea5505e1815d9f&#34;&gt;よくわからないフラグ処理がされている&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;do_fizz&lt;/code&gt; と &lt;code&gt;do_buzz&lt;/code&gt; が関数名から何をするのかさっぱりわからない。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;do_fizz&lt;/code&gt; は &lt;em&gt;3で割り切れる場合 1 を返し、それ以外の場合は 0 を返す関数である&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;do_buzz&lt;/code&gt; は &lt;em&gt;5で割り切れる場合 2 を返し、それ以外の場合は 0 を返す関数である&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ということはコードをよまなければわからない。ならば、関数の頭にコメントをかくか、そのような名前の関数にすべきだと思う。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;do_&lt;/code&gt; という接頭辞が着いている以上何かする関数だと想像するので、ここで &lt;code&gt;print&lt;/code&gt; されているのであれば、まだ良いと思うけど, iPhoneで閲覧していたらこの命名のせいで混乱しました。&lt;/p&gt;

&lt;h2 id=&#34;do-answer-の引数が意味不明:aa533cc5bfd0e8e446ea5505e1815d9f&#34;&gt;do_answer の引数が意味不明&lt;/h2&gt;

&lt;p&gt;fizz って何? buzz って何?&lt;/p&gt;

&lt;p&gt;&lt;code&gt;do_answer(do_fizz(int), do_buzz(int))&lt;/code&gt; これをみてわけがわかる人がいたら教えて欲しい。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;do_fizz&lt;/code&gt; と &lt;code&gt;do_buzz&lt;/code&gt; の実行結果を使うのであれば、関数内で使うべきだろう。&lt;code&gt;int&lt;/code&gt;をdo_answer に渡さない設計にしているのに &lt;code&gt;do_fizz&lt;/code&gt; と &lt;code&gt;do_buzz&lt;/code&gt; に渡しているのに ここで int の文字がふたつ見える。 &lt;strong&gt;わけがわからないよ&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;do_answer&lt;/code&gt; は &lt;code&gt;print&lt;/code&gt; するという点でまあ良いのじゃないかと思う。
ただ、doしないversionを用意しておけば&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;for n in range(1,int):
   print answer(do_fizz(n), do_buzz(n))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とかきかえることができて、&lt;code&gt;int&lt;/code&gt;までの FizzBuzz が表示できてナイスだと思います。&lt;/p&gt;

&lt;h2 id=&#34;まとめ:aa533cc5bfd0e8e446ea5505e1815d9f&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;「Haskell と Ruby で書いたらどうなるかを書け」という煽りな気がしたけど無視してみた。&lt;/p&gt;

&lt;p&gt;ついで、個人的感想。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;「Pythonって三項演算子どうやるんだろ？」って思ったんで調べて使ってみた。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;たぶん、&lt;code&gt;and&lt;/code&gt; &lt;code&gt;or&lt;/code&gt; で同様のことはできるけど、&lt;strong&gt;「3項演算子は読みにくいから使うな。」&lt;/strong&gt; ってことだと思う。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;phpの&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;$flag[] = (int % 3 == 0) ? 1 : 0;
$flag[] = (int % 5 == 0) ? 2 : 0;

$flag[&#39;fizz&#39;] = (int % 3 == 0) ? 1 :0;
$flag[&#39;buzz&#39;] = (int % 5 == 0) ? 2 :0;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;みたいにいきなりList（配列）を作る書き方がPythonでも出来ると思うんだけど知識不足。
公式チュートリアルやったらどっかで出てくるかな？ｗ&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;初期化してない変数に無理矢理突っ込むということのほうがおかしい。
かくなら&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;flag = []
flag.append(fizz)
flag.append(buzz)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となるのではないでしょうか。&lt;/p&gt;

&lt;p&gt;このように中途半端なコードを書いて誰かを煽ると添削とかしてもらえるらしいです。非常に勉強する際にショートカットになりますし、煽られるほうも勉強になります。どんどん真似していきましょう。&lt;/p&gt;

&lt;p&gt;まあ、せっかくなので Haskell でも書いておきました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import Control.Monad

main = do
  putStr &amp;quot;please enter an integer:&amp;quot;
  number &amp;lt;- fmap read $ getLine
  putStrLn . fizzbuzz $ number
  -- forM_ [1..number] $ \n -&amp;gt;
  --       putStrLn . fizzbuzz $ n

fizzbuzz :: Int -&amp;gt; String
fizzbuzz n | n `mod` 15 == 0 = &amp;quot;FizzBuzz&amp;quot;
           | n `mod`  5 == 0 = &amp;quot;Buzz&amp;quot;
           | n `mod`  3 == 0 = &amp;quot;Fizz&amp;quot;
           | otherwise       = show n
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再帰についても書きたいですが、話がずれてしまうので、また別の機会に。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/eiel/soudai-FizzBuzz&#34;&gt;リポジトリはこちらに用意しておきました。&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;トマホークおまちしています。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>読書メモ 関数プログラミング入門 Haskellで学ぶ原理と技法 1.5 定義</title>
          <link>https://blog.eiel.info/blog/2013/01/24/intro-functional-1-dot-5/</link>
          <pubDate>Thu, 24 Jan 2013 23:51:00 &#43;0900</pubDate>
          <author>Tomohiko Himura</author>
          <guid>https://blog.eiel.info/blog/2013/01/24/intro-functional-1-dot-5/</guid>
          <description>

&lt;p&gt;&lt;a href=&#34;http://www.amazon.co.jp/gp/product/427406896X/ref=as_li_ss_tl?ie=UTF8&amp;amp;camp=247&amp;amp;creative=7399&amp;amp;creativeASIN=427406896X&amp;amp;linkCode=as2&amp;amp;tag=eiel-22&#34;&gt;関数プログラミング入門 Haskell で学ぶ原理と技法&lt;/a&gt; の読書メモです。&lt;/p&gt;

&lt;p&gt;本節は&lt;strong&gt;定義&lt;/strong&gt;についてですが、前節につづき&lt;strong&gt;関数&lt;/strong&gt;ともいえそうです。&lt;/p&gt;

&lt;p&gt;内容は
* ガード付等式
* 再帰定義
* 局所定義
です。&lt;/p&gt;

&lt;p&gt;ガード式の前に関数だけじゃなく、他の値も定義できるという話がでてきますが、それ以上でもそれ以下でもないです。一般的なプログラミング言語なら定数ともいえそうです。&lt;/p&gt;

&lt;p&gt;つづいて、ガード付等式です。&lt;code&gt;ガード 付等式&lt;/code&gt; か &lt;code&gt;ガード付 等式&lt;/code&gt;悩みましたがたぶん後者でしょう。
まだ、登場していませんが、パターンマッチよりも細かいところで分岐させるのによく使います。数学のノートみたいに見えてよいです。一応例をだしておきます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;compare x y
  | x &amp;gt; y  = LEFT
  | x == y = EQUAL
  | x &amp;lt; y  = RIGHT
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;LEFT、EQUAL RIGHTの定義をしていませんが、比較して大きいほうを返す関数です。よみやすいです。このように3パターン以上に分岐する場合は &lt;code&gt;if&lt;/code&gt; を使用するよりもよみやすくなります。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;if&lt;/code&gt;を使うと&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;compare x y = if x &amp;gt; y then LEFT else
                       if x == y then EQUAL else RIGHT
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;みたいな感じでしょう。&lt;/p&gt;

&lt;h2 id=&#34;再帰定義:368c9568204ac0b705e48e5803b91b91&#34;&gt;再帰定義&lt;/h2&gt;

&lt;p&gt;あまり文章での説明がなかったです。関数の中で自分の名前が使用できます。実際に手を動かして簡約してみると、再帰というものが存在して良いことが確認できると思います。
ただし、&lt;strong&gt;終了条件&lt;/strong&gt;がなければ収束することなくどんどん大きくなります。&lt;/p&gt;

&lt;h2 id=&#34;局所定義:368c9568204ac0b705e48e5803b91b91&#34;&gt;局所定義&lt;/h2&gt;

&lt;p&gt;関数にローカルな定数や関数を定義できます。引数から値をとってきて別の関数に引数を適用しておいて使いますなどすると便利です。
一時変数のように使えますが、当然再代入はできません。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;let&lt;/code&gt;が登場しませんでした。複雑さを回避したのでしょうか。&lt;/p&gt;

&lt;h2 id=&#34;練習問題:368c9568204ac0b705e48e5803b91b91&#34;&gt;練習問題&lt;/h2&gt;

&lt;p&gt;ひさしぶりに Haskellのコードをかかせてくれました。&lt;/p&gt;

&lt;h2 id=&#34;まとめ:368c9568204ac0b705e48e5803b91b91&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;ガード付等式はここで登場で良いのかよくわからなかったですが、知っておくほうが便利です。それにしても、Haskellの表記は数学に近いようになってて楽しいですね。&lt;/p&gt;

&lt;h2 id=&#34;関連:368c9568204ac0b705e48e5803b91b91&#34;&gt;関連&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/eiel/Introduction-to-Functional-Programming-using-Haskell/blob/master/1/index.org&#34;&gt;メモ用のリポジトリ 1章&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/eiel/Introduction-to-Functional-Programming-using-Haskell/blob/master/1/1.5.hs&#34;&gt;1.5の練習問題&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
      
    
      
        <item>
          <title>読書メモ 関数プログラミング入門 Haskellで学ぶ原理と技法 1.4 関数</title>
          <link>https://blog.eiel.info/blog/2013/01/22/intro-functional-1-dot-4/</link>
          <pubDate>Tue, 22 Jan 2013 23:17:00 &#43;0900</pubDate>
          <author>Tomohiko Himura</author>
          <guid>https://blog.eiel.info/blog/2013/01/22/intro-functional-1-dot-4/</guid>
          <description>

&lt;p&gt;&lt;a href=&#34;http://www.amazon.co.jp/gp/product/427406896X/ref=as_li_ss_tl?ie=UTF8&amp;amp;camp=247&amp;amp;creative=7399&amp;amp;creativeASIN=427406896X&amp;amp;linkCode=as2&amp;amp;tag=eiel-22&#34;&gt;関数プログラミング入門 Haskell で学ぶ原理と技法&lt;/a&gt; の読書メモです。&lt;/p&gt;

&lt;p&gt;本節は &lt;strong&gt;関数&lt;/strong&gt; について。&lt;/p&gt;

&lt;p&gt;要点は&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;外延性&lt;/li&gt;
&lt;li&gt;カリー化&lt;/li&gt;
&lt;li&gt;演算子と関数&lt;/li&gt;
&lt;li&gt;優先順位 結合順序&lt;/li&gt;
&lt;li&gt;関数合成&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;です&lt;/p&gt;

&lt;p&gt;まず関数は値として扱えますが、表示することはできません。引数を適用することで表示できる場合があります。
また、関数は 引数の値 を戻り値 の型に変換する(対応をつける)役目をもちます。関数の型を示すには -&amp;gt; 演算子を使い 型A を受取り 型B を返す場合 &lt;code&gt;A -&amp;gt; B&lt;/code&gt; とかきます。&lt;/p&gt;

&lt;p&gt;関数 と 関数に値を適用したものを混同しないように気をつけたほうがよいそうです。&lt;/p&gt;

&lt;h2 id=&#34;外延性:6fdffeb2d4f0779613cf55b32efa20e3&#34;&gt;外延性&lt;/h2&gt;

&lt;p&gt;関数が等しい場合は任意のxに対し以下が成立します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;f x = g x
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この方法は関数に値を適用した結果が一致するので 適用的証明 というそうです。また ポイントワイズスタイル ともいうそうです。このように f や g はブラックボックスですが、引数と結果で確認できるので&lt;strong&gt;外延性の原理&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;逆に定義から &lt;code&gt;f = g&lt;/code&gt; を示す場合はポイントフリースタイルというそうです。ただし、効率が違う場合があり、これは内包的性質というそうです。&lt;/p&gt;

&lt;h2 id=&#34;カリー化:6fdffeb2d4f0779613cf55b32efa20e3&#34;&gt;カリー化&lt;/h2&gt;

&lt;p&gt;単一の引数の関数の複数の引数に分解できます。こうすると関数に引数をひとつだけ適用すると新しい関数を作成することができます。結果が変わらないので括弧が減ったり、引数を変えるだけで様々な効果をもつ関数がつくれる利点があります。Arrow を使う場合は逆に アンカリー化をする場合もあります。&lt;/p&gt;

&lt;h2 id=&#34;演算子と関数:6fdffeb2d4f0779613cf55b32efa20e3&#34;&gt;演算子と関数&lt;/h2&gt;

&lt;p&gt;演算子も実質的には2引数の関数ですが中置することができます。Haskellでは 括弧で演算子を囲むことで通常の関数にもできますし、関数をバッククォートで囲むことで演算子のように利用できます。また、括弧で演算子を囲む場合は &lt;code&gt;(+1)&lt;/code&gt; のようにして あらかじめ引数を適用したりもできます。これをセクションというそうです。&lt;/p&gt;

&lt;h2 id=&#34;優先順位-結合順序:6fdffeb2d4f0779613cf55b32efa20e3&#34;&gt;優先順位 結合順序&lt;/h2&gt;

&lt;p&gt;これらのおかげで 括弧を省略することができます。
これらの把握しておかないとHaskellのコードを読む際によくわからなくなるのでしっかりと慣れておいたほうが良いです。&lt;/p&gt;

&lt;p&gt;関数は最優先で左結合です。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;f x y + z&lt;/code&gt; であれば &lt;code&gt;((f x) y) + z&lt;/code&gt; と等価です。&lt;/p&gt;

&lt;p&gt;右結合か左結合か は演算子によって違いますが、どちらでも同じ結果になるものもあります。これを結合性というそうです。+ や * は結合性があります。&lt;/p&gt;

&lt;h2 id=&#34;関数合成:6fdffeb2d4f0779613cf55b32efa20e3&#34;&gt;関数合成&lt;/h2&gt;

&lt;p&gt;関数合成は関数と関数を演算できます。結合性です。
ある関数の結果を別の関数の引数にできる場合に利用できます。
&lt;code&gt;f (g x)&lt;/code&gt; が正しい場合 &lt;code&gt;(f . g) x&lt;/code&gt; とできます。ドットは関数合成をする演算子です。&lt;/p&gt;

&lt;h2 id=&#34;まとめ:6fdffeb2d4f0779613cf55b32efa20e3&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;練習問題は今回もHaskell のコードはあまりかきませんでした。&lt;/p&gt;

&lt;p&gt;優先順位や結合順序はいままでなんとなくでやってましたが、改めて整理できたのでかなり Haskell のコードがよみやすくなりました。早めに習得しておきたいですね。&lt;/p&gt;

&lt;h2 id=&#34;関連:6fdffeb2d4f0779613cf55b32efa20e3&#34;&gt;関連&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/eiel/Introduction-to-Functional-Programming-using-Haskell/blob/master/1/index.org&#34;&gt;メモ用のリポジトリ 1章&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/eiel/Introduction-to-Functional-Programming-using-Haskell/blob/master/1/1.4.md&#34;&gt;1.4の練習問題&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
      
    
      
        <item>
          <title>読書メモ 関数プログラミング入門 Haskellで学ぶ原理と技法 1.3 値</title>
          <link>https://blog.eiel.info/blog/2013/01/15/intro-functional-1-dot-3/</link>
          <pubDate>Tue, 15 Jan 2013 01:17:00 &#43;0900</pubDate>
          <author>Tomohiko Himura</author>
          <guid>https://blog.eiel.info/blog/2013/01/15/intro-functional-1-dot-3/</guid>
          <description>

&lt;p&gt;&lt;a href=&#34;http://www.amazon.co.jp/gp/product/427406896X/ref=as_li_ss_tl?ie=UTF8&amp;amp;camp=247&amp;amp;creative=7399&amp;amp;creativeASIN=427406896X&amp;amp;linkCode=as2&amp;amp;tag=eiel-22&#34;&gt;関数プログラミング入門 Haskell で学ぶ原理と技法&lt;/a&gt; の読書メモです。&lt;/p&gt;

&lt;p&gt;本節は &lt;strong&gt;値&lt;/strong&gt; について。&lt;/p&gt;

&lt;p&gt;値と式の関係。値と正格関数、非正格関数。がメインです。&lt;/p&gt;

&lt;p&gt;値は 式を用いて表現できます。値を表現する式はひとつだけではなく、複数存在し、評価機が出力する表現は &lt;strong&gt;標準表現&lt;/strong&gt; が利用されます。基本的には評価可能な式が表示されるということのようです。Rubyでいうと pメソッドの出力結果に近そうです。
また、値を表示しようとすると停止しない可能性が存在します。このような状態になる関数を正格関数と呼びます。具体的にシンプルに定義されてるのでわかりやすいです。正格でない関数は非正格なりますが、これは遅延評価でないと定義できないそうです。&lt;/p&gt;

&lt;p&gt;練習問題は正格と非正格について考える問題でした。&lt;/p&gt;

&lt;h2 id=&#34;関連:203e25fa29b2dcca1df36333d28ffc0a&#34;&gt;関連&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/eiel/Introduction-to-Functional-Programming-using-Haskell/blob/master/1/index.org&#34;&gt;メモ用のリポジトリ 1章&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/eiel/Introduction-to-Functional-Programming-using-Haskell/blob/master/1/1.3.md&#34;&gt;1.3の練習問題&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
      
    
      
        <item>
          <title>読書メモ 関数プログラミング入門 Haskellで学ぶ原理と技法 1.2 評価</title>
          <link>https://blog.eiel.info/blog/2013/01/13/intro-functional-1-dot-2/</link>
          <pubDate>Sun, 13 Jan 2013 21:47:00 &#43;0900</pubDate>
          <author>Tomohiko Himura</author>
          <guid>https://blog.eiel.info/blog/2013/01/13/intro-functional-1-dot-2/</guid>
          <description>

&lt;p&gt;&lt;a href=&#34;http://www.amazon.co.jp/gp/product/427406896X/ref=as_li_ss_tl?ie=UTF8&amp;amp;camp=247&amp;amp;creative=7399&amp;amp;creativeASIN=427406896X&amp;amp;linkCode=as2&amp;amp;tag=eiel-22&#34;&gt;関数プログラミング入門 Haskell で学ぶ原理と技法&lt;/a&gt; の読書メモです。&lt;/p&gt;

&lt;p&gt;本節は評価を中心に式の簡約化についての説明です。&lt;/p&gt;

&lt;p&gt;正規形という形を目指して式を簡略化していきますが、関数プログラミングにおいては、どのような手順で簡約しても最終結果が一致するのが特徴です。&lt;/p&gt;

&lt;p&gt;代入のような破壊的な操作が存在する世界では、順序が影響します。
そこが命令型のプログラミングと違うところでしょう。そのため並列処理させるたべ順序に影響しないため、関数プログラミングが評価されてる部分だと思います。&lt;/p&gt;

&lt;p&gt;話が脱線しましたが、簡約の手順には 1つだけでなく複数存在する可能性があります。そのためプログラミング言語によっては簡約の評価戦略が違うようです。
あと、簡約の手順が違う場合、停止しない場合が存在することもあります。&lt;/p&gt;

&lt;p&gt;練習問題は評価の順序、停止性について考えるような問題でした。&lt;/p&gt;

&lt;h2 id=&#34;関連:5809e91198f962082c9b9e2f02a14bd0&#34;&gt;関連&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/eiel/Introduction-to-Functional-Programming-using-Haskell/blob/master/1/index.org&#34;&gt;メモ用のリポジトリ 1章&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/eiel/Introduction-to-Functional-Programming-using-Haskell/blob/master/1/1.2.md&#34;&gt;1.2の練習問題&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
      
    
      
        <item>
          <title>読書メモ 関数プログラミング入門 Haskellで学ぶ原理と技法 1.1 セッションとスクリプト</title>
          <link>https://blog.eiel.info/blog/2013/01/13/intro-functional-1-dot-1/</link>
          <pubDate>Sun, 13 Jan 2013 18:46:00 &#43;0900</pubDate>
          <author>Tomohiko Himura</author>
          <guid>https://blog.eiel.info/blog/2013/01/13/intro-functional-1-dot-1/</guid>
          <description>

&lt;p&gt;&lt;a href=&#34;http://www.amazon.co.jp/gp/product/427406896X/ref=as_li_ss_tl?ie=UTF8&amp;amp;camp=247&amp;amp;creative=7399&amp;amp;creativeASIN=427406896X&amp;amp;linkCode=as2&amp;amp;tag=eiel-22&#34;&gt;関数プログラミング入門 Haskell で学ぶ原理と技法&lt;/a&gt; の読書メモです。&lt;/p&gt;

&lt;p&gt;本書は 2002年に出版された&lt;a href=&#34;http://www.amazon.co.jp/gp/product/0134843460/ref=as_li_ss_tl?ie=UTF8&amp;amp;camp=247&amp;amp;creative=7399&amp;amp;creativeASIN=0134843460&amp;amp;linkCode=as2&amp;amp;tag=eiel-22&#34;&gt;Introduction to Functional Programming using Haskell&lt;/a&gt; の2版の翻訳です。
いまになって日本語に訳されたということはそれなりの名著なのかなー。ということで、Haskellネタを書く機会があまりなかったので、読書メモを書いていこうと思います。&lt;/p&gt;

&lt;p&gt;問題を解いてくのに最強の環境をつくろうぜ。と、意訳できる文章ではじまります。本節は Hugs を使用することを想定して セッション、スクリプトといった対話環境だからこそしっくりくる用語を中心に基本用語が解説されています。&lt;/p&gt;

&lt;p&gt;スクリプトによって定義を追加していき環境を構築した上で &lt;strong&gt;式を評価&lt;/strong&gt; するというのが主軸なのかなあ、と思います。環境/文脈は束縛の集りであるというのは非常にシンプルで実際の文脈の小ささは関数プログラミングの特徴と言えるのではないかな、と思いました。&lt;/p&gt;

&lt;p&gt;あとは、定義には関数の定義がかかれ、関数には 型シグネチャ をかけることぐらいかな。&lt;/p&gt;

&lt;p&gt;練習問題が関数定義の練習と束縛済みの関数を再利用するのが目的な感じでした。&lt;/p&gt;

&lt;h2 id=&#34;関連:b051e3dc2a6d3d92bfdd286396d33718&#34;&gt;関連&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/eiel/Introduction-to-Functional-Programming-using-Haskell/blob/master/1/index.org&#34;&gt;メモ用のリポジトリ 1章&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/eiel/Introduction-to-Functional-Programming-using-Haskell/blob/master/1/1.1.hs&#34;&gt;1.1の練習問題&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;iframe src=&#34;http://rcm-jp.amazon.co.jp/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=eiel-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=427406896X&#34; style=&#34;width:120px;height:240px;&#34; scrolling=&#34;no&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;
</description>
        </item>
      
    
      
        <item>
          <title>プログラムミングにおけるモナドと圏論との対応。</title>
          <link>https://blog.eiel.info/blog/2012/06/07/monad-memo/</link>
          <pubDate>Thu, 07 Jun 2012 17:57:00 &#43;0900</pubDate>
          <author>Tomohiko Himura</author>
          <guid>https://blog.eiel.info/blog/2012/06/07/monad-memo/</guid>
          <description>&lt;p&gt;説明するわけではないです。メモです。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Kleisli圏&lt;/code&gt; をキーワードに調べると気になるということがわかったのでメモしておきます。&lt;/p&gt;

&lt;p&gt;その中で気になったもの&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://tnomura9.exblog.jp/12138525/&#34;&gt;tnomuraのブログのブログ - モナドのKleisli圏&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://takeichi.ipl-lab.org/~hamana/local/monad2.pdf&#34;&gt;関数型プログラマのためのモナド理論&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://d.hatena.ne.jp/m-hiyama/20060821/1156120185&#34;&gt;はじめての圏論 その第1歩&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;単にHaskellをするのに圏論の理解は不要です。使うだけなら馴れるだけで十分だと思います。モナドの表現力がどのようなところまであるのか、そのあたりを知りたいのです。&lt;/p&gt;
</description>
        </item>
      
    

  </channel>
</rss>
